
;;; All the macros and the scheme-object printing procedure
;;; are defined in compiler.s
%include "compiler.s"

section .bss
;;; This pointer is used to manage allocations on our heap.
malloc_pointer:
    resq 1

section .data
const_tbl:
MAKE_VOID
MAKE_NIL
MAKE_BOOL(0)
MAKE_BOOL(1)
MAKE_LITERAL_STRING "whatever",8
MAKE_LITERAL_SYMBOL(const_tbl+6)
MAKE_LITERAL_INT(1)
MAKE_LITERAL_INT(0)
MAKE_LITERAL_CHAR(0)
MAKE_LITERAL_INT(2)
MAKE_LITERAL_PAIR(const_tbl+52, const_tbl+1)
MAKE_LITERAL_PAIR(const_tbl+32, const_tbl+61)

;;; These macro definitions are required for the primitive
;;; definitions in the epilogue to work properly
%define SOB_VOID_ADDRESS const_tbl+0
%define SOB_NIL_ADDRESS const_tbl+1
%define SOB_FALSE_ADDRESS const_tbl+2
%define SOB_TRUE_ADDRESS const_tbl+4

fvar_tbl:
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED

global main
section .text
main:
    push rbp

    ;; set up the heap
    mov rdi, GB(4)
    call malloc
    mov [malloc_pointer], rax

    ;; Set up the dummy activation frame
    ;; The dummy return address is T_UNDEFINED
    ;; (which a is a macro for 0) so that returning
    ;; from the top level (which SHOULD NOT HAPPEN
    ;; AND IS A BUG) will cause a segfault.
    push 0
    push qword SOB_NIL_ADDRESS
    push qword T_UNDEFINED
    push rsp
    mov rbp,rsp

    ;; Set up the primitive stdlib fvars:
    ;; Since the primtive procedures are defined in assembly,
    ;; they are not generated by scheme (define ...) expressions.
    ;; This is where we emulate the missing (define ...) expressions
    ;; for all the primitive procedures.
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_boolean)
    mov [fvar_tbl+8*0], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_float)
    mov [fvar_tbl+8*1], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_integer)
    mov [fvar_tbl+8*2], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_pair)
    mov [fvar_tbl+8*3], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_null)
    mov [fvar_tbl+8*4], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_char)
    mov [fvar_tbl+8*5], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_string)
    mov [fvar_tbl+8*7], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_procedure)
    mov [fvar_tbl+8*8], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_symbol)
    mov [fvar_tbl+8*9], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, string_length)
    mov [fvar_tbl+8*10], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, string_ref)
    mov [fvar_tbl+8*11], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, string_set)
    mov [fvar_tbl+8*12], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, make_string)
    mov [fvar_tbl+8*13], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, symbol_to_string)
    mov [fvar_tbl+8*18], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, char_to_integer)
    mov [fvar_tbl+8*19], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, integer_to_char)
    mov [fvar_tbl+8*20], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_eq)
    mov [fvar_tbl+8*21], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, bin_add)
    mov [fvar_tbl+8*22], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, bin_mul)
    mov [fvar_tbl+8*23], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, bin_sub)
    mov [fvar_tbl+8*24], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, bin_div)
    mov [fvar_tbl+8*25], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, bin_lt)
    mov [fvar_tbl+8*26], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, bin_equ)
    mov [fvar_tbl+8*27], rax

user_code_fragment:
;;; The code you compiled will be catenated here.
;;; It will be executed immediately after the closures for 
;;; the primitive procedures are set up.


push SOB_NIL_ADDRESS		 ; comment nadav

mov rax, qword [fvar_tbl + 8*32]

push rax

mov rax, qword [fvar_tbl + 8*33]

push rax

mov rax, qword [fvar_tbl + 8*29]

push rax

mov rax, qword [fvar_tbl + 8*28]

push rax

mov rax, qword [fvar_tbl + 8*4]

push rax

push 6
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode_14785251)
jmp Lcont_14785251
Lcode_14785251:
push rbp
mov rbp, rsp

push SOB_NIL_ADDRESS		 ; comment nadav

mov rax, const_tbl+23

push rax

push 2

mov rsi, [rbp + 8 * 3]			;; (*rsi holds the number of parametres on the stack*)
lea rsi, [rsi * 8]
inc rsi			;;(*rsi holds the number of bytes to allocate for the new vector which is number_of_params + 1 (for magic)*)
MALLOC rdx, rsi			;; (*now rdx points to the allocated memory for the new vector*)
mov rcx, [rbp + 8 * 3]
inc rcx			;;(*rcx holds the number of parametres on the stack + 1 (for magic),  rcx is the loop counter*)
mov rdi, 0			;;(*rdi will be used to point to the next address in the vector*)

mov r9, 4
;; (*start of loop to copy parameters to the new allocated vector*)
copy_params_loop_858766356:
cmp rdi, rcx
je after_params_copy_858766356
mov rsi, [rbp + 8 * r9]			;;(*now rsi points to the next parameter on the stack*)
mov [rdx + 8*rdi], rsi			;;(*copying the parameter to the new allocated vector*)
inc rdi
inc r9
jmp copy_params_loop_858766356
;; (*now rdx points to the new vector to be added to ext_env*)
;; (*mov 0 to all neccessary registers*)
after_params_copy_858766356:
mov rcx, 0
mov rdi, 0
mov rsi, 0
;; (*now we need to create ext_env by copying env and adding the new vector*)
MALLOC rbx, 16			;;(*rbx points to a new allocated space for ext_env*)
mov [rbx], rdx			;;(*coping the new vector to ext_env[0]*)
mov rsi, [rbp + 8 * 2]			;;(*rsi points to current env*)
mov rcx, 1			;;(*rcx is the loop counter*)
mov r9, 0			;;(*r9 will be used to point to the next vector in current env to be copied*)
mov rdi, 1			;;(*rdi will be used to point to the next address in ext_env*)
mov r8, 0
;; (*start of loop for copying env[i] to ext_env[i+1]*)
copy_env_loop_858766356:
cmp r9, rcx
je after_env_copy_858766356
mov r8, [rsi + 8 * r9]			;;(*r8 points to the next vector int current env to be copied*) 
mov [rbx + 8 * rdi], r8			;;(*copying the pointer to the vector from env to ext_env*)
inc r9
inc rdi
jmp copy_env_loop_858766356
after_env_copy_858766356:

MAKE_CLOSURE(rax, rbx, Lcode_858766356)
jmp Lcont_858766356
Lcode_858766356:
push rbp
mov rbp, rsp

mov qword rax, [rbp + 32]
MALLOC r11, 8
mov qword [r11], rax
mov rax, r11

mov qword [rbp + 32], rax
mov rax, SOB_VOID_ADDRESS



mov rax, 1
push rax
mov qword rax, [rbp + 32]

pop qword [rax]
mov rax, SOB_VOID_ADDRESS


mov qword rax, [rbp + 32]

mov rax, qword [rax]



leave
ret
Lcont_858766356:


push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
after_applic_713567136:

leave
ret
Lcont_14785251:


push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
after_applic_621731022:

mov [fvar_tbl + 8*34], rax
mov rax, SOB_VOID_ADDRESS
	call write_sob_if_not_void

MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode_139310441)
jmp Lcont_139310441
Lcode_139310441:
push rbp
mov rbp, rsp

push SOB_NIL_ADDRESS		 ; comment nadav


push SOB_NIL_ADDRESS		 ; comment nadav


push SOB_NIL_ADDRESS		 ; comment nadav

mov qword rax, [rbp + 48]

push rax

push 2
mov rax, qword [fvar_tbl + 8*28]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
after_applic_479628152:

push rax

mov qword rax, [rbp + 40]

push rax

push 3
mov qword rax, [rbp + 32]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
after_applic_530108890:

push rax

push 2

mov rsi, [rbp + 8 * 3]			;; (*rsi holds the number of parametres on the stack*)
lea rsi, [rsi * 8]
inc rsi			;;(*rsi holds the number of bytes to allocate for the new vector which is number_of_params + 1 (for magic)*)
MALLOC rdx, rsi			;; (*now rdx points to the allocated memory for the new vector*)
mov rcx, [rbp + 8 * 3]
inc rcx			;;(*rcx holds the number of parametres on the stack + 1 (for magic),  rcx is the loop counter*)
mov rdi, 0			;;(*rdi will be used to point to the next address in the vector*)

mov r9, 4
;; (*start of loop to copy parameters to the new allocated vector*)
copy_params_loop_744807207:
cmp rdi, rcx
je after_params_copy_744807207
mov rsi, [rbp + 8 * r9]			;;(*now rsi points to the next parameter on the stack*)
mov [rdx + 8*rdi], rsi			;;(*copying the parameter to the new allocated vector*)
inc rdi
inc r9
jmp copy_params_loop_744807207
;; (*now rdx points to the new vector to be added to ext_env*)
;; (*mov 0 to all neccessary registers*)
after_params_copy_744807207:
mov rcx, 0
mov rdi, 0
mov rsi, 0
;; (*now we need to create ext_env by copying env and adding the new vector*)
MALLOC rbx, 16			;;(*rbx points to a new allocated space for ext_env*)
mov [rbx], rdx			;;(*coping the new vector to ext_env[0]*)
mov rsi, [rbp + 8 * 2]			;;(*rsi points to current env*)
mov rcx, 1			;;(*rcx is the loop counter*)
mov r9, 0			;;(*r9 will be used to point to the next vector in current env to be copied*)
mov rdi, 1			;;(*rdi will be used to point to the next address in ext_env*)
mov r8, 0
;; (*start of loop for copying env[i] to ext_env[i+1]*)
copy_env_loop_744807207:
cmp r9, rcx
je after_env_copy_744807207
mov r8, [rsi + 8 * r9]			;;(*r8 points to the next vector int current env to be copied*) 
mov [rbx + 8 * rdi], r8			;;(*copying the pointer to the vector from env to ext_env*)
inc r9
inc rdi
jmp copy_env_loop_744807207
after_env_copy_744807207:

MAKE_CLOSURE(rax, rbx, Lcode_744807207)
jmp Lcont_744807207
Lcode_744807207:
push rbp
mov rbp, rsp

push SOB_NIL_ADDRESS		 ; comment nadav

mov rax, const_tbl+1

push rax


push SOB_NIL_ADDRESS		 ; comment nadav

mov rax, qword [rbp + 16]
mov rax, qword [rax + 0]
mov rax, qword [rax + 16]

push rax

push 2
mov rax, qword [fvar_tbl + 8*29]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
after_applic_510529514:

push rax

push 3
mov rax, qword [fvar_tbl + 8*21]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
after_applic_483666380:

cmp rax, SOB_FALSE_ADDRESS
je Lelse_847232054
mov qword rax, [rbp + 32]

jmp Lexit_308140838
Lelse_847232054:

push SOB_NIL_ADDRESS		 ; comment nadav


push SOB_NIL_ADDRESS		 ; comment nadav

mov rax, qword [rbp + 16]
mov rax, qword [rax + 0]
mov rax, qword [rax + 16]

push rax

push 2
mov rax, qword [fvar_tbl + 8*29]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
after_applic_198288938:

push rax

mov qword rax, [rbp + 32]

push rax

mov rax, qword [rbp + 16]
mov rax, qword [rax + 0]
mov rax, qword [rax + 0]

push rax

push 4
mov rax, qword [fvar_tbl + 8*35]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
after_applic_304507802:

Lexit_308140838:

leave
ret
Lcont_744807207:


push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
after_applic_743829425:

leave
ret
Lcont_139310441:


mov [fvar_tbl + 8*35], rax
mov rax, SOB_VOID_ADDRESS
	call write_sob_if_not_void

MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode_15076718)
jmp Lcont_15076718
Lcode_15076718:
push rbp
mov rbp, rsp

push SOB_NIL_ADDRESS		 ; comment nadav

mov rax, const_tbl+23

push rax

mov rax, const_tbl+23

push rax

push 3

mov rsi, [rbp + 8 * 3]			;; (*rsi holds the number of parametres on the stack*)
lea rsi, [rsi * 8]
inc rsi			;;(*rsi holds the number of bytes to allocate for the new vector which is number_of_params + 1 (for magic)*)
MALLOC rdx, rsi			;; (*now rdx points to the allocated memory for the new vector*)
mov rcx, [rbp + 8 * 3]
inc rcx			;;(*rcx holds the number of parametres on the stack + 1 (for magic),  rcx is the loop counter*)
mov rdi, 0			;;(*rdi will be used to point to the next address in the vector*)

mov r9, 4
;; (*start of loop to copy parameters to the new allocated vector*)
copy_params_loop_599609540:
cmp rdi, rcx
je after_params_copy_599609540
mov rsi, [rbp + 8 * r9]			;;(*now rsi points to the next parameter on the stack*)
mov [rdx + 8*rdi], rsi			;;(*copying the parameter to the new allocated vector*)
inc rdi
inc r9
jmp copy_params_loop_599609540
;; (*now rdx points to the new vector to be added to ext_env*)
;; (*mov 0 to all neccessary registers*)
after_params_copy_599609540:
mov rcx, 0
mov rdi, 0
mov rsi, 0
;; (*now we need to create ext_env by copying env and adding the new vector*)
MALLOC rbx, 16			;;(*rbx points to a new allocated space for ext_env*)
mov [rbx], rdx			;;(*coping the new vector to ext_env[0]*)
mov rsi, [rbp + 8 * 2]			;;(*rsi points to current env*)
mov rcx, 1			;;(*rcx is the loop counter*)
mov r9, 0			;;(*r9 will be used to point to the next vector in current env to be copied*)
mov rdi, 1			;;(*rdi will be used to point to the next address in ext_env*)
mov r8, 0
;; (*start of loop for copying env[i] to ext_env[i+1]*)
copy_env_loop_599609540:
cmp r9, rcx
je after_env_copy_599609540
mov r8, [rsi + 8 * r9]			;;(*r8 points to the next vector int current env to be copied*) 
mov [rbx + 8 * rdi], r8			;;(*copying the pointer to the vector from env to ext_env*)
inc r9
inc rdi
jmp copy_env_loop_599609540
after_env_copy_599609540:

MAKE_CLOSURE(rax, rbx, Lcode_599609540)
jmp Lcont_599609540
Lcode_599609540:
push rbp
mov rbp, rsp

mov qword rax, [rbp + 40]
MALLOC r11, 8
mov qword [r11], rax
mov rax, r11

mov qword [rbp + 40], rax
mov rax, SOB_VOID_ADDRESS




push SOB_NIL_ADDRESS		 ; comment nadav

mov rax, qword [rbp + 16]
mov rax, qword [rax + 0]
mov rax, qword [rax + 16]

push rax

push 2
mov rax, qword [fvar_tbl + 8*37]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
after_applic_942578091:

mov qword [rbp + 32], rax
mov rax, SOB_VOID_ADDRESS



mov rsi, [rbp + 8 * 3]			;; (*rsi holds the number of parametres on the stack*)
lea rsi, [rsi * 8]
inc rsi			;;(*rsi holds the number of bytes to allocate for the new vector which is number_of_params + 1 (for magic)*)
MALLOC rdx, rsi			;; (*now rdx points to the allocated memory for the new vector*)
mov rcx, [rbp + 8 * 3]
inc rcx			;;(*rcx holds the number of parametres on the stack + 1 (for magic),  rcx is the loop counter*)
mov rdi, 0			;;(*rdi will be used to point to the next address in the vector*)

mov r9, 4
;; (*start of loop to copy parameters to the new allocated vector*)
copy_params_loop_463926866:
cmp rdi, rcx
je after_params_copy_463926866
mov rsi, [rbp + 8 * r9]			;;(*now rsi points to the next parameter on the stack*)
mov [rdx + 8*rdi], rsi			;;(*copying the parameter to the new allocated vector*)
inc rdi
inc r9
jmp copy_params_loop_463926866
;; (*now rdx points to the new vector to be added to ext_env*)
;; (*mov 0 to all neccessary registers*)
after_params_copy_463926866:
mov rcx, 0
mov rdi, 0
mov rsi, 0
;; (*now we need to create ext_env by copying env and adding the new vector*)
MALLOC rbx, 24			;;(*rbx points to a new allocated space for ext_env*)
mov [rbx], rdx			;;(*coping the new vector to ext_env[0]*)
mov rsi, [rbp + 8 * 2]			;;(*rsi points to current env*)
mov rcx, 2			;;(*rcx is the loop counter*)
mov r9, 0			;;(*r9 will be used to point to the next vector in current env to be copied*)
mov rdi, 1			;;(*rdi will be used to point to the next address in ext_env*)
mov r8, 0
;; (*start of loop for copying env[i] to ext_env[i+1]*)
copy_env_loop_463926866:
cmp r9, rcx
je after_env_copy_463926866
mov r8, [rsi + 8 * r9]			;;(*r8 points to the next vector int current env to be copied*) 
mov [rbx + 8 * rdi], r8			;;(*copying the pointer to the vector from env to ext_env*)
inc r9
inc rdi
jmp copy_env_loop_463926866
after_env_copy_463926866:

MAKE_CLOSURE(rax, rbx, Lcode_463926866)
jmp Lcont_463926866
Lcode_463926866:
push rbp
mov rbp, rsp

push SOB_NIL_ADDRESS		 ; comment nadav


push SOB_NIL_ADDRESS		 ; comment nadav

mov qword rax, [rbp + 40]

push rax


push SOB_NIL_ADDRESS		 ; comment nadav

mov qword rax, [rbp + 48]

push rax

push 2
mov rax, qword [fvar_tbl + 8*28]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
after_applic_977879997:

push rax

push 3
mov qword rax, [rbp + 32]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
after_applic_575223720:

push rax

push 2

mov rsi, [rbp + 8 * 3]			;; (*rsi holds the number of parametres on the stack*)
lea rsi, [rsi * 8]
inc rsi			;;(*rsi holds the number of bytes to allocate for the new vector which is number_of_params + 1 (for magic)*)
MALLOC rdx, rsi			;; (*now rdx points to the allocated memory for the new vector*)
mov rcx, [rbp + 8 * 3]
inc rcx			;;(*rcx holds the number of parametres on the stack + 1 (for magic),  rcx is the loop counter*)
mov rdi, 0			;;(*rdi will be used to point to the next address in the vector*)

mov r9, 4
;; (*start of loop to copy parameters to the new allocated vector*)
copy_params_loop_283791396:
cmp rdi, rcx
je after_params_copy_283791396
mov rsi, [rbp + 8 * r9]			;;(*now rsi points to the next parameter on the stack*)
mov [rdx + 8*rdi], rsi			;;(*copying the parameter to the new allocated vector*)
inc rdi
inc r9
jmp copy_params_loop_283791396
;; (*now rdx points to the new vector to be added to ext_env*)
;; (*mov 0 to all neccessary registers*)
after_params_copy_283791396:
mov rcx, 0
mov rdi, 0
mov rsi, 0
;; (*now we need to create ext_env by copying env and adding the new vector*)
MALLOC rbx, 32			;;(*rbx points to a new allocated space for ext_env*)
mov [rbx], rdx			;;(*coping the new vector to ext_env[0]*)
mov rsi, [rbp + 8 * 2]			;;(*rsi points to current env*)
mov rcx, 3			;;(*rcx is the loop counter*)
mov r9, 0			;;(*r9 will be used to point to the next vector in current env to be copied*)
mov rdi, 1			;;(*rdi will be used to point to the next address in ext_env*)
mov r8, 0
;; (*start of loop for copying env[i] to ext_env[i+1]*)
copy_env_loop_283791396:
cmp r9, rcx
je after_env_copy_283791396
mov r8, [rsi + 8 * r9]			;;(*r8 points to the next vector int current env to be copied*) 
mov [rbx + 8 * rdi], r8			;;(*copying the pointer to the vector from env to ext_env*)
inc r9
inc rdi
jmp copy_env_loop_283791396
after_env_copy_283791396:

MAKE_CLOSURE(rax, rbx, Lcode_283791396)
jmp Lcont_283791396
Lcode_283791396:
push rbp
mov rbp, rsp

push SOB_NIL_ADDRESS		 ; comment nadav

mov rax, const_tbl+1

push rax


push SOB_NIL_ADDRESS		 ; comment nadav

mov rax, qword [rbp + 16]
mov rax, qword [rax + 0]
mov rax, qword [rax + 16]

push rax

push 2
mov rax, qword [fvar_tbl + 8*29]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
after_applic_793128188:

push rax

push 3
mov rax, qword [fvar_tbl + 8*21]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
after_applic_868569136:

cmp rax, SOB_FALSE_ADDRESS
je Lelse_380528153
mov qword rax, [rbp + 32]

jmp Lexit_541080542
Lelse_380528153:

push SOB_NIL_ADDRESS		 ; comment nadav


push SOB_NIL_ADDRESS		 ; comment nadav

mov rax, qword [rbp + 16]
mov rax, qword [rax + 0]
mov rax, qword [rax + 16]

push rax

push 2
mov rax, qword [fvar_tbl + 8*29]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
after_applic_407118687:

push rax

mov qword rax, [rbp + 32]

push rax

mov rax, qword [rbp + 16]
mov rax, qword [rax + 0]
mov rax, qword [rax + 0]

push rax

push 4
mov rax, qword [rbp + 16]
mov rax, qword [rax + 8]
mov rax, qword [rax + 8]

mov rax, qword [rax]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
after_applic_269997124:

Lexit_541080542:

leave
ret
Lcont_283791396:


push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
after_applic_435807891:

leave
ret
Lcont_463926866:


push rax
mov qword rax, [rbp + 40]

pop qword [rax]
mov rax, SOB_VOID_ADDRESS



push SOB_NIL_ADDRESS		 ; comment nadav

mov qword rax, [rbp + 32]

push rax

mov rax, qword [rbp + 16]
mov rax, qword [rax + 0]
mov rax, qword [rax + 8]

push rax

mov rax, qword [rbp + 16]
mov rax, qword [rax + 0]
mov rax, qword [rax + 0]

push rax

push 4
mov qword rax, [rbp + 40]

mov rax, qword [rax]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
after_applic_844370963:



leave
ret
Lcont_599609540:


push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
after_applic_663533580:

leave
ret
Lcont_15076718:


mov [fvar_tbl + 8*36], rax
mov rax, SOB_VOID_ADDRESS
	call write_sob_if_not_void

mov rax, 1
mov [fvar_tbl + 8*38], rax
mov rax, SOB_VOID_ADDRESS
	call write_sob_if_not_void


push SOB_NIL_ADDRESS		 ; comment nadav

mov rax, qword [fvar_tbl + 8*33]

push rax

mov rax, qword [fvar_tbl + 8*36]

push rax

mov rax, qword [fvar_tbl + 8*4]

push rax

push 4
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode_367008404)
jmp Lcont_367008404
Lcode_367008404:
push rbp
mov rbp, rsp
mov rax, 1
leave
ret
Lcont_367008404:


push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
after_applic_771724904:

mov [fvar_tbl + 8*40], rax
mov rax, SOB_VOID_ADDRESS
	call write_sob_if_not_void

mov rax, 1
mov [fvar_tbl + 8*41], rax
mov rax, SOB_VOID_ADDRESS
	call write_sob_if_not_void


push SOB_NIL_ADDRESS		 ; comment nadav

mov rax, qword [fvar_tbl + 8*29]

push rax

mov rax, qword [fvar_tbl + 8*3]

push rax

mov rax, qword [fvar_tbl + 8*4]

push rax

push 4
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode_661312616)
jmp Lcont_661312616
Lcode_661312616:
push rbp
mov rbp, rsp

push SOB_NIL_ADDRESS		 ; comment nadav

mov rax, const_tbl+23

push rax

push 2

mov rsi, [rbp + 8 * 3]			;; (*rsi holds the number of parametres on the stack*)
lea rsi, [rsi * 8]
inc rsi			;;(*rsi holds the number of bytes to allocate for the new vector which is number_of_params + 1 (for magic)*)
MALLOC rdx, rsi			;; (*now rdx points to the allocated memory for the new vector*)
mov rcx, [rbp + 8 * 3]
inc rcx			;;(*rcx holds the number of parametres on the stack + 1 (for magic),  rcx is the loop counter*)
mov rdi, 0			;;(*rdi will be used to point to the next address in the vector*)

mov r9, 4
;; (*start of loop to copy parameters to the new allocated vector*)
copy_params_loop_525340320:
cmp rdi, rcx
je after_params_copy_525340320
mov rsi, [rbp + 8 * r9]			;;(*now rsi points to the next parameter on the stack*)
mov [rdx + 8*rdi], rsi			;;(*copying the parameter to the new allocated vector*)
inc rdi
inc r9
jmp copy_params_loop_525340320
;; (*now rdx points to the new vector to be added to ext_env*)
;; (*mov 0 to all neccessary registers*)
after_params_copy_525340320:
mov rcx, 0
mov rdi, 0
mov rsi, 0
;; (*now we need to create ext_env by copying env and adding the new vector*)
MALLOC rbx, 16			;;(*rbx points to a new allocated space for ext_env*)
mov [rbx], rdx			;;(*coping the new vector to ext_env[0]*)
mov rsi, [rbp + 8 * 2]			;;(*rsi points to current env*)
mov rcx, 1			;;(*rcx is the loop counter*)
mov r9, 0			;;(*r9 will be used to point to the next vector in current env to be copied*)
mov rdi, 1			;;(*rdi will be used to point to the next address in ext_env*)
mov r8, 0
;; (*start of loop for copying env[i] to ext_env[i+1]*)
copy_env_loop_525340320:
cmp r9, rcx
je after_env_copy_525340320
mov r8, [rsi + 8 * r9]			;;(*r8 points to the next vector int current env to be copied*) 
mov [rbx + 8 * rdi], r8			;;(*copying the pointer to the vector from env to ext_env*)
inc r9
inc rdi
jmp copy_env_loop_525340320
after_env_copy_525340320:

MAKE_CLOSURE(rax, rbx, Lcode_525340320)
jmp Lcont_525340320
Lcode_525340320:
push rbp
mov rbp, rsp


mov rsi, [rbp + 8 * 3]			;; (*rsi holds the number of parametres on the stack*)
lea rsi, [rsi * 8]
inc rsi			;;(*rsi holds the number of bytes to allocate for the new vector which is number_of_params + 1 (for magic)*)
MALLOC rdx, rsi			;; (*now rdx points to the allocated memory for the new vector*)
mov rcx, [rbp + 8 * 3]
inc rcx			;;(*rcx holds the number of parametres on the stack + 1 (for magic),  rcx is the loop counter*)
mov rdi, 0			;;(*rdi will be used to point to the next address in the vector*)

mov r9, 4
;; (*start of loop to copy parameters to the new allocated vector*)
copy_params_loop_882359236:
cmp rdi, rcx
je after_params_copy_882359236
mov rsi, [rbp + 8 * r9]			;;(*now rsi points to the next parameter on the stack*)
mov [rdx + 8*rdi], rsi			;;(*copying the parameter to the new allocated vector*)
inc rdi
inc r9
jmp copy_params_loop_882359236
;; (*now rdx points to the new vector to be added to ext_env*)
;; (*mov 0 to all neccessary registers*)
after_params_copy_882359236:
mov rcx, 0
mov rdi, 0
mov rsi, 0
;; (*now we need to create ext_env by copying env and adding the new vector*)
MALLOC rbx, 24			;;(*rbx points to a new allocated space for ext_env*)
mov [rbx], rdx			;;(*coping the new vector to ext_env[0]*)
mov rsi, [rbp + 8 * 2]			;;(*rsi points to current env*)
mov rcx, 2			;;(*rcx is the loop counter*)
mov r9, 0			;;(*r9 will be used to point to the next vector in current env to be copied*)
mov rdi, 1			;;(*rdi will be used to point to the next address in ext_env*)
mov r8, 0
;; (*start of loop for copying env[i] to ext_env[i+1]*)
copy_env_loop_882359236:
cmp r9, rcx
je after_env_copy_882359236
mov r8, [rsi + 8 * r9]			;;(*r8 points to the next vector int current env to be copied*) 
mov [rbx + 8 * rdi], r8			;;(*copying the pointer to the vector from env to ext_env*)
inc r9
inc rdi
jmp copy_env_loop_882359236
after_env_copy_882359236:

MAKE_CLOSURE(rax, rbx, Lcode_882359236)
jmp Lcont_882359236
Lcode_882359236:
push rbp
mov rbp, rsp

push SOB_NIL_ADDRESS		 ; comment nadav

mov qword rax, [rbp + 32]

push rax

push 2
mov rax, qword [rbp + 16]
mov rax, qword [rax + 8]
mov rax, qword [rax + 0]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
after_applic_355434846:

cmp rax, SOB_FALSE_ADDRESS
jne Lexit_644830334

push SOB_NIL_ADDRESS		 ; comment nadav

mov qword rax, [rbp + 32]

push rax

push 2
mov rax, qword [rbp + 16]
mov rax, qword [rax + 8]
mov rax, qword [rax + 8]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
after_applic_583061130:

cmp rax, SOB_FALSE_ADDRESS
je Lelse_911393886

push SOB_NIL_ADDRESS		 ; comment nadav


push SOB_NIL_ADDRESS		 ; comment nadav

mov qword rax, [rbp + 32]

push rax

push 2
mov rax, qword [rbp + 16]
mov rax, qword [rax + 8]
mov rax, qword [rax + 16]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
after_applic_904360012:

push rax

push 2
mov rax, qword [fvar_tbl + 8*42]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
after_applic_157380188:

jmp Lexit_222584391
Lelse_911393886:
mov rax, const_tbl+2

Lexit_222584391:

Lexit_644830334:

leave
ret
Lcont_882359236:


mov qword [rbp + 32], rax
mov rax, SOB_VOID_ADDRESS


mov qword rax, [rbp + 32]


leave
ret
Lcont_525340320:


push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
after_applic_231413264:

leave
ret
Lcont_661312616:


push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
after_applic_634982515:

mov [fvar_tbl + 8*42], rax
mov rax, SOB_VOID_ADDRESS
	call write_sob_if_not_void


push SOB_NIL_ADDRESS		 ; comment nadav

mov rax, qword [fvar_tbl + 8*22]

push rax

mov rax, qword [fvar_tbl + 8*35]

push rax

push 3
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode_675348438)
jmp Lcont_675348438
Lcode_675348438:
push rbp
mov rbp, rsp

mov rsi, [rbp + 8 * 3]			;; (*rsi holds the number of parametres on the stack*)
lea rsi, [rsi * 8]
inc rsi			;;(*rsi holds the number of bytes to allocate for the new vector which is number_of_params + 1 (for magic)*)
MALLOC rdx, rsi			;; (*now rdx points to the allocated memory for the new vector*)
mov rcx, [rbp + 8 * 3]
inc rcx			;;(*rcx holds the number of parametres on the stack + 1 (for magic),  rcx is the loop counter*)
mov rdi, 0			;;(*rdi will be used to point to the next address in the vector*)

mov r9, 4
;; (*start of loop to copy parameters to the new allocated vector*)
copy_params_loop_67564655:
cmp rdi, rcx
je after_params_copy_67564655
mov rsi, [rbp + 8 * r9]			;;(*now rsi points to the next parameter on the stack*)
mov [rdx + 8*rdi], rsi			;;(*copying the parameter to the new allocated vector*)
inc rdi
inc r9
jmp copy_params_loop_67564655
;; (*now rdx points to the new vector to be added to ext_env*)
;; (*mov 0 to all neccessary registers*)
after_params_copy_67564655:
mov rcx, 0
mov rdi, 0
mov rsi, 0
;; (*now we need to create ext_env by copying env and adding the new vector*)
MALLOC rbx, 16			;;(*rbx points to a new allocated space for ext_env*)
mov [rbx], rdx			;;(*coping the new vector to ext_env[0]*)
mov rsi, [rbp + 8 * 2]			;;(*rsi points to current env*)
mov rcx, 1			;;(*rcx is the loop counter*)
mov r9, 0			;;(*r9 will be used to point to the next vector in current env to be copied*)
mov rdi, 1			;;(*rdi will be used to point to the next address in ext_env*)
mov r8, 0
;; (*start of loop for copying env[i] to ext_env[i+1]*)
copy_env_loop_67564655:
cmp r9, rcx
je after_env_copy_67564655
mov r8, [rsi + 8 * r9]			;;(*r8 points to the next vector int current env to be copied*) 
mov [rbx + 8 * rdi], r8			;;(*copying the pointer to the vector from env to ext_env*)
inc r9
inc rdi
jmp copy_env_loop_67564655
after_env_copy_67564655:

MAKE_CLOSURE(rax, rbx, Lcode_67564655)
jmp Lcont_67564655
Lcode_67564655:
push rbp
mov rbp, rsp

push SOB_NIL_ADDRESS		 ; comment nadav

mov qword rax, [rbp + 32]

push rax

mov rax, const_tbl+41

push rax


mov rsi, [rbp + 8 * 3]			;; (*rsi holds the number of parametres on the stack*)
lea rsi, [rsi * 8]
inc rsi			;;(*rsi holds the number of bytes to allocate for the new vector which is number_of_params + 1 (for magic)*)
MALLOC rdx, rsi			;; (*now rdx points to the allocated memory for the new vector*)
mov rcx, [rbp + 8 * 3]
inc rcx			;;(*rcx holds the number of parametres on the stack + 1 (for magic),  rcx is the loop counter*)
mov rdi, 0			;;(*rdi will be used to point to the next address in the vector*)

mov r9, 4
;; (*start of loop to copy parameters to the new allocated vector*)
copy_params_loop_837406327:
cmp rdi, rcx
je after_params_copy_837406327
mov rsi, [rbp + 8 * r9]			;;(*now rsi points to the next parameter on the stack*)
mov [rdx + 8*rdi], rsi			;;(*copying the parameter to the new allocated vector*)
inc rdi
inc r9
jmp copy_params_loop_837406327
;; (*now rdx points to the new vector to be added to ext_env*)
;; (*mov 0 to all neccessary registers*)
after_params_copy_837406327:
mov rcx, 0
mov rdi, 0
mov rsi, 0
;; (*now we need to create ext_env by copying env and adding the new vector*)
MALLOC rbx, 24			;;(*rbx points to a new allocated space for ext_env*)
mov [rbx], rdx			;;(*coping the new vector to ext_env[0]*)
mov rsi, [rbp + 8 * 2]			;;(*rsi points to current env*)
mov rcx, 2			;;(*rcx is the loop counter*)
mov r9, 0			;;(*r9 will be used to point to the next vector in current env to be copied*)
mov rdi, 1			;;(*rdi will be used to point to the next address in ext_env*)
mov r8, 0
;; (*start of loop for copying env[i] to ext_env[i+1]*)
copy_env_loop_837406327:
cmp r9, rcx
je after_env_copy_837406327
mov r8, [rsi + 8 * r9]			;;(*r8 points to the next vector int current env to be copied*) 
mov [rbx + 8 * rdi], r8			;;(*copying the pointer to the vector from env to ext_env*)
inc r9
inc rdi
jmp copy_env_loop_837406327
after_env_copy_837406327:

MAKE_CLOSURE(rax, rbx, Lcode_837406327)
jmp Lcont_837406327
Lcode_837406327:
push rbp
mov rbp, rsp

push SOB_NIL_ADDRESS		 ; comment nadav

mov rax, const_tbl+32

push rax

mov qword rax, [rbp + 32]

push rax

push 3
mov rax, qword [rbp + 16]
mov rax, qword [rax + 8]
mov rax, qword [rax + 8]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
after_applic_905522432:

leave
ret
Lcont_837406327:


push rax

push 4
mov rax, qword [rbp + 16]
mov rax, qword [rax + 0]
mov rax, qword [rax + 0]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
after_applic_259038460:

leave
ret
Lcont_67564655:


leave
ret
Lcont_675348438:


push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
after_applic_551702454:

mov [fvar_tbl + 8*39], rax
mov rax, SOB_VOID_ADDRESS
	call write_sob_if_not_void


push SOB_NIL_ADDRESS		 ; comment nadav

mov rax, qword [fvar_tbl + 8*13]

push rax

mov rax, qword [fvar_tbl + 8*28]

push rax

mov rax, qword [fvar_tbl + 8*4]

push rax

push 4
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode_640034938)
jmp Lcont_640034938
Lcode_640034938:
push rbp
mov rbp, rsp
mov rax, 1
leave
ret
Lcont_640034938:


push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
after_applic_395313404:

mov [fvar_tbl + 8*13], rax
mov rax, SOB_VOID_ADDRESS
	call write_sob_if_not_void

MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode_326105067)
jmp Lcont_326105067
Lcode_326105067:
push rbp
mov rbp, rsp
mov qword rax, [rbp + 32]

cmp rax, SOB_FALSE_ADDRESS
je Lelse_409307569
mov rax, const_tbl+2

jmp Lexit_681013979
Lelse_409307569:
mov rax, const_tbl+4

Lexit_681013979:

leave
ret
Lcont_326105067:


mov [fvar_tbl + 8*43], rax
mov rax, SOB_VOID_ADDRESS
	call write_sob_if_not_void


push SOB_NIL_ADDRESS		 ; comment nadav

mov rax, qword [fvar_tbl + 8*2]

push rax

mov rax, qword [fvar_tbl + 8*1]

push rax

push 3
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode_274455462)
jmp Lcont_274455462
Lcode_274455462:
push rbp
mov rbp, rsp

mov rsi, [rbp + 8 * 3]			;; (*rsi holds the number of parametres on the stack*)
lea rsi, [rsi * 8]
inc rsi			;;(*rsi holds the number of bytes to allocate for the new vector which is number_of_params + 1 (for magic)*)
MALLOC rdx, rsi			;; (*now rdx points to the allocated memory for the new vector*)
mov rcx, [rbp + 8 * 3]
inc rcx			;;(*rcx holds the number of parametres on the stack + 1 (for magic),  rcx is the loop counter*)
mov rdi, 0			;;(*rdi will be used to point to the next address in the vector*)

mov r9, 4
;; (*start of loop to copy parameters to the new allocated vector*)
copy_params_loop_672812566:
cmp rdi, rcx
je after_params_copy_672812566
mov rsi, [rbp + 8 * r9]			;;(*now rsi points to the next parameter on the stack*)
mov [rdx + 8*rdi], rsi			;;(*copying the parameter to the new allocated vector*)
inc rdi
inc r9
jmp copy_params_loop_672812566
;; (*now rdx points to the new vector to be added to ext_env*)
;; (*mov 0 to all neccessary registers*)
after_params_copy_672812566:
mov rcx, 0
mov rdi, 0
mov rsi, 0
;; (*now we need to create ext_env by copying env and adding the new vector*)
MALLOC rbx, 16			;;(*rbx points to a new allocated space for ext_env*)
mov [rbx], rdx			;;(*coping the new vector to ext_env[0]*)
mov rsi, [rbp + 8 * 2]			;;(*rsi points to current env*)
mov rcx, 1			;;(*rcx is the loop counter*)
mov r9, 0			;;(*r9 will be used to point to the next vector in current env to be copied*)
mov rdi, 1			;;(*rdi will be used to point to the next address in ext_env*)
mov r8, 0
;; (*start of loop for copying env[i] to ext_env[i+1]*)
copy_env_loop_672812566:
cmp r9, rcx
je after_env_copy_672812566
mov r8, [rsi + 8 * r9]			;;(*r8 points to the next vector int current env to be copied*) 
mov [rbx + 8 * rdi], r8			;;(*copying the pointer to the vector from env to ext_env*)
inc r9
inc rdi
jmp copy_env_loop_672812566
after_env_copy_672812566:

MAKE_CLOSURE(rax, rbx, Lcode_672812566)
jmp Lcont_672812566
Lcode_672812566:
push rbp
mov rbp, rsp

push SOB_NIL_ADDRESS		 ; comment nadav

mov qword rax, [rbp + 32]

push rax

push 2
mov rax, qword [rbp + 16]
mov rax, qword [rax + 0]
mov rax, qword [rax + 0]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
after_applic_6123927:

cmp rax, SOB_FALSE_ADDRESS
jne Lexit_566618411

push SOB_NIL_ADDRESS		 ; comment nadav

mov qword rax, [rbp + 32]

push rax

push 2
mov rax, qword [rbp + 16]
mov rax, qword [rax + 0]
mov rax, qword [rax + 8]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
after_applic_832502760:

Lexit_566618411:

leave
ret
Lcont_672812566:


leave
ret
Lcont_274455462:


push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
after_applic_937227572:

mov [fvar_tbl + 8*44], rax
mov rax, SOB_VOID_ADDRESS
	call write_sob_if_not_void


push SOB_NIL_ADDRESS		 ; comment nadav

mov rax, qword [fvar_tbl + 8*22]

push rax

mov rax, qword [fvar_tbl + 8*35]

push rax

push 3
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode_565297347)
jmp Lcont_565297347
Lcode_565297347:
push rbp
mov rbp, rsp
mov rax, 1
leave
ret
Lcont_565297347:


push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
after_applic_285021971:

mov [fvar_tbl + 8*22], rax
mov rax, SOB_VOID_ADDRESS
	call write_sob_if_not_void


push SOB_NIL_ADDRESS		 ; comment nadav

mov rax, qword [fvar_tbl + 8*23]

push rax

mov rax, qword [fvar_tbl + 8*35]

push rax

push 3
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode_98100301)
jmp Lcont_98100301
Lcode_98100301:
push rbp
mov rbp, rsp
mov rax, 1
leave
ret
Lcont_98100301:


push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
after_applic_44907061:

mov [fvar_tbl + 8*23], rax
mov rax, SOB_VOID_ADDRESS
	call write_sob_if_not_void


push SOB_NIL_ADDRESS		 ; comment nadav

mov rax, qword [fvar_tbl + 8*4]

push rax

mov rax, qword [fvar_tbl + 8*22]

push rax

mov rax, qword [fvar_tbl + 8*24]

push rax

mov rax, qword [fvar_tbl + 8*32]

push rax

push 5
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode_115132095)
jmp Lcont_115132095
Lcode_115132095:
push rbp
mov rbp, rsp
mov rax, 1
leave
ret
Lcont_115132095:


push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
after_applic_246489982:

mov [fvar_tbl + 8*24], rax
mov rax, SOB_VOID_ADDRESS
	call write_sob_if_not_void


push SOB_NIL_ADDRESS		 ; comment nadav

mov rax, qword [fvar_tbl + 8*4]

push rax

mov rax, qword [fvar_tbl + 8*23]

push rax

mov rax, qword [fvar_tbl + 8*25]

push rax

mov rax, qword [fvar_tbl + 8*32]

push rax

push 5
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode_513666613)
jmp Lcont_513666613
Lcode_513666613:
push rbp
mov rbp, rsp
mov rax, 1
leave
ret
Lcont_513666613:


push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
after_applic_408226969:

mov [fvar_tbl + 8*25], rax
mov rax, SOB_VOID_ADDRESS
	call write_sob_if_not_void


push SOB_NIL_ADDRESS		 ; comment nadav

mov rax, qword [fvar_tbl + 8*32]

push rax

mov rax, qword [fvar_tbl + 8*29]

push rax

mov rax, qword [fvar_tbl + 8*28]

push rax

mov rax, qword [fvar_tbl + 8*4]

push rax

mov rax, qword [fvar_tbl + 8*27]

push rax

push 6
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode_658392294)
jmp Lcont_658392294
Lcode_658392294:
push rbp
mov rbp, rsp

push SOB_NIL_ADDRESS		 ; comment nadav

mov rax, const_tbl+23

push rax

push 2

mov rsi, [rbp + 8 * 3]			;; (*rsi holds the number of parametres on the stack*)
lea rsi, [rsi * 8]
inc rsi			;;(*rsi holds the number of bytes to allocate for the new vector which is number_of_params + 1 (for magic)*)
MALLOC rdx, rsi			;; (*now rdx points to the allocated memory for the new vector*)
mov rcx, [rbp + 8 * 3]
inc rcx			;;(*rcx holds the number of parametres on the stack + 1 (for magic),  rcx is the loop counter*)
mov rdi, 0			;;(*rdi will be used to point to the next address in the vector*)

mov r9, 4
;; (*start of loop to copy parameters to the new allocated vector*)
copy_params_loop_808498156:
cmp rdi, rcx
je after_params_copy_808498156
mov rsi, [rbp + 8 * r9]			;;(*now rsi points to the next parameter on the stack*)
mov [rdx + 8*rdi], rsi			;;(*copying the parameter to the new allocated vector*)
inc rdi
inc r9
jmp copy_params_loop_808498156
;; (*now rdx points to the new vector to be added to ext_env*)
;; (*mov 0 to all neccessary registers*)
after_params_copy_808498156:
mov rcx, 0
mov rdi, 0
mov rsi, 0
;; (*now we need to create ext_env by copying env and adding the new vector*)
MALLOC rbx, 16			;;(*rbx points to a new allocated space for ext_env*)
mov [rbx], rdx			;;(*coping the new vector to ext_env[0]*)
mov rsi, [rbp + 8 * 2]			;;(*rsi points to current env*)
mov rcx, 1			;;(*rcx is the loop counter*)
mov r9, 0			;;(*r9 will be used to point to the next vector in current env to be copied*)
mov rdi, 1			;;(*rdi will be used to point to the next address in ext_env*)
mov r8, 0
;; (*start of loop for copying env[i] to ext_env[i+1]*)
copy_env_loop_808498156:
cmp r9, rcx
je after_env_copy_808498156
mov r8, [rsi + 8 * r9]			;;(*r8 points to the next vector int current env to be copied*) 
mov [rbx + 8 * rdi], r8			;;(*copying the pointer to the vector from env to ext_env*)
inc r9
inc rdi
jmp copy_env_loop_808498156
after_env_copy_808498156:

MAKE_CLOSURE(rax, rbx, Lcode_808498156)
jmp Lcont_808498156
Lcode_808498156:
push rbp
mov rbp, rsp

mov qword rax, [rbp + 32]
MALLOC r11, 8
mov qword [r11], rax
mov rax, r11

mov qword [rbp + 32], rax
mov rax, SOB_VOID_ADDRESS



mov rax, 1
push rax
mov qword rax, [rbp + 32]

pop qword [rax]
mov rax, SOB_VOID_ADDRESS


mov qword rax, [rbp + 32]

mov rax, qword [rax]



leave
ret
Lcont_808498156:


push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
after_applic_732603925:

leave
ret
Lcont_658392294:


push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
after_applic_301578941:

mov [fvar_tbl + 8*27], rax
mov rax, SOB_VOID_ADDRESS
	call write_sob_if_not_void


push SOB_NIL_ADDRESS		 ; comment nadav

mov rax, qword [fvar_tbl + 8*29]

push rax

mov rax, qword [fvar_tbl + 8*28]

push rax

mov rax, qword [fvar_tbl + 8*26]

push rax

mov rax, qword [fvar_tbl + 8*4]

push rax

push 5
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode_735962992)
jmp Lcont_735962992
Lcode_735962992:
push rbp
mov rbp, rsp

push SOB_NIL_ADDRESS		 ; comment nadav

mov rax, const_tbl+23

push rax

push 2

mov rsi, [rbp + 8 * 3]			;; (*rsi holds the number of parametres on the stack*)
lea rsi, [rsi * 8]
inc rsi			;;(*rsi holds the number of bytes to allocate for the new vector which is number_of_params + 1 (for magic)*)
MALLOC rdx, rsi			;; (*now rdx points to the allocated memory for the new vector*)
mov rcx, [rbp + 8 * 3]
inc rcx			;;(*rcx holds the number of parametres on the stack + 1 (for magic),  rcx is the loop counter*)
mov rdi, 0			;;(*rdi will be used to point to the next address in the vector*)

mov r9, 4
;; (*start of loop to copy parameters to the new allocated vector*)
copy_params_loop_142687140:
cmp rdi, rcx
je after_params_copy_142687140
mov rsi, [rbp + 8 * r9]			;;(*now rsi points to the next parameter on the stack*)
mov [rdx + 8*rdi], rsi			;;(*copying the parameter to the new allocated vector*)
inc rdi
inc r9
jmp copy_params_loop_142687140
;; (*now rdx points to the new vector to be added to ext_env*)
;; (*mov 0 to all neccessary registers*)
after_params_copy_142687140:
mov rcx, 0
mov rdi, 0
mov rsi, 0
;; (*now we need to create ext_env by copying env and adding the new vector*)
MALLOC rbx, 16			;;(*rbx points to a new allocated space for ext_env*)
mov [rbx], rdx			;;(*coping the new vector to ext_env[0]*)
mov rsi, [rbp + 8 * 2]			;;(*rsi points to current env*)
mov rcx, 1			;;(*rcx is the loop counter*)
mov r9, 0			;;(*r9 will be used to point to the next vector in current env to be copied*)
mov rdi, 1			;;(*rdi will be used to point to the next address in ext_env*)
mov r8, 0
;; (*start of loop for copying env[i] to ext_env[i+1]*)
copy_env_loop_142687140:
cmp r9, rcx
je after_env_copy_142687140
mov r8, [rsi + 8 * r9]			;;(*r8 points to the next vector int current env to be copied*) 
mov [rbx + 8 * rdi], r8			;;(*copying the pointer to the vector from env to ext_env*)
inc r9
inc rdi
jmp copy_env_loop_142687140
after_env_copy_142687140:

MAKE_CLOSURE(rax, rbx, Lcode_142687140)
jmp Lcont_142687140
Lcode_142687140:
push rbp
mov rbp, rsp

mov qword rax, [rbp + 32]
MALLOC r11, 8
mov qword [r11], rax
mov rax, r11

mov qword [rbp + 32], rax
mov rax, SOB_VOID_ADDRESS




mov rsi, [rbp + 8 * 3]			;; (*rsi holds the number of parametres on the stack*)
lea rsi, [rsi * 8]
inc rsi			;;(*rsi holds the number of bytes to allocate for the new vector which is number_of_params + 1 (for magic)*)
MALLOC rdx, rsi			;; (*now rdx points to the allocated memory for the new vector*)
mov rcx, [rbp + 8 * 3]
inc rcx			;;(*rcx holds the number of parametres on the stack + 1 (for magic),  rcx is the loop counter*)
mov rdi, 0			;;(*rdi will be used to point to the next address in the vector*)

mov r9, 4
;; (*start of loop to copy parameters to the new allocated vector*)
copy_params_loop_337561787:
cmp rdi, rcx
je after_params_copy_337561787
mov rsi, [rbp + 8 * r9]			;;(*now rsi points to the next parameter on the stack*)
mov [rdx + 8*rdi], rsi			;;(*copying the parameter to the new allocated vector*)
inc rdi
inc r9
jmp copy_params_loop_337561787
;; (*now rdx points to the new vector to be added to ext_env*)
;; (*mov 0 to all neccessary registers*)
after_params_copy_337561787:
mov rcx, 0
mov rdi, 0
mov rsi, 0
;; (*now we need to create ext_env by copying env and adding the new vector*)
MALLOC rbx, 24			;;(*rbx points to a new allocated space for ext_env*)
mov [rbx], rdx			;;(*coping the new vector to ext_env[0]*)
mov rsi, [rbp + 8 * 2]			;;(*rsi points to current env*)
mov rcx, 2			;;(*rcx is the loop counter*)
mov r9, 0			;;(*r9 will be used to point to the next vector in current env to be copied*)
mov rdi, 1			;;(*rdi will be used to point to the next address in ext_env*)
mov r8, 0
;; (*start of loop for copying env[i] to ext_env[i+1]*)
copy_env_loop_337561787:
cmp r9, rcx
je after_env_copy_337561787
mov r8, [rsi + 8 * r9]			;;(*r8 points to the next vector int current env to be copied*) 
mov [rbx + 8 * rdi], r8			;;(*copying the pointer to the vector from env to ext_env*)
inc r9
inc rdi
jmp copy_env_loop_337561787
after_env_copy_337561787:

MAKE_CLOSURE(rax, rbx, Lcode_337561787)
jmp Lcont_337561787
Lcode_337561787:
push rbp
mov rbp, rsp

push SOB_NIL_ADDRESS		 ; comment nadav

mov qword rax, [rbp + 40]

push rax

push 2
mov rax, qword [rbp + 16]
mov rax, qword [rax + 8]
mov rax, qword [rax + 0]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
after_applic_909437959:

cmp rax, SOB_FALSE_ADDRESS
je Lelse_196223014
mov rax, const_tbl+4

jmp Lexit_170783178
Lelse_196223014:

push SOB_NIL_ADDRESS		 ; comment nadav


push SOB_NIL_ADDRESS		 ; comment nadav

mov qword rax, [rbp + 40]

push rax

push 2
mov rax, qword [rbp + 16]
mov rax, qword [rax + 8]
mov rax, qword [rax + 16]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
after_applic_230494162:

push rax

mov qword rax, [rbp + 32]

push rax

push 3
mov rax, qword [rbp + 16]
mov rax, qword [rax + 8]
mov rax, qword [rax + 8]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
after_applic_661528186:

cmp rax, SOB_FALSE_ADDRESS
je Lelse_700349737

push SOB_NIL_ADDRESS		 ; comment nadav


push SOB_NIL_ADDRESS		 ; comment nadav

mov qword rax, [rbp + 40]

push rax

push 2
mov rax, qword [rbp + 16]
mov rax, qword [rax + 8]
mov rax, qword [rax + 24]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
after_applic_96734197:

push rax


push SOB_NIL_ADDRESS		 ; comment nadav

mov qword rax, [rbp + 40]

push rax

push 2
mov rax, qword [rbp + 16]
mov rax, qword [rax + 8]
mov rax, qword [rax + 16]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
after_applic_107290671:

push rax

push 3
mov rax, qword [rbp + 16]
mov rax, qword [rax + 0]
mov rax, qword [rax + 0]

mov rax, qword [rax]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
after_applic_359421285:

jmp Lexit_323318772
Lelse_700349737:
mov rax, const_tbl+2

Lexit_323318772:

Lexit_170783178:

leave
ret
Lcont_337561787:


push rax
mov qword rax, [rbp + 32]

pop qword [rax]
mov rax, SOB_VOID_ADDRESS


mov rax, 1


leave
ret
Lcont_142687140:


push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
after_applic_478170254:

leave
ret
Lcont_735962992:


push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
after_applic_866852534:

mov [fvar_tbl + 8*26], rax
mov rax, SOB_VOID_ADDRESS
	call write_sob_if_not_void


push SOB_NIL_ADDRESS		 ; comment nadav

mov rax, qword [fvar_tbl + 8*29]

push rax

mov rax, qword [fvar_tbl + 8*28]

push rax

mov rax, qword [fvar_tbl + 8*43]

push rax

mov rax, qword [fvar_tbl + 8*27]

push rax

mov rax, qword [fvar_tbl + 8*26]

push rax

mov rax, qword [fvar_tbl + 8*4]

push rax

push 7
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode_798031681)
jmp Lcont_798031681
Lcode_798031681:
push rbp
mov rbp, rsp

push SOB_NIL_ADDRESS		 ; comment nadav

mov rax, const_tbl+23

push rax

push 2

mov rsi, [rbp + 8 * 3]			;; (*rsi holds the number of parametres on the stack*)
lea rsi, [rsi * 8]
inc rsi			;;(*rsi holds the number of bytes to allocate for the new vector which is number_of_params + 1 (for magic)*)
MALLOC rdx, rsi			;; (*now rdx points to the allocated memory for the new vector*)
mov rcx, [rbp + 8 * 3]
inc rcx			;;(*rcx holds the number of parametres on the stack + 1 (for magic),  rcx is the loop counter*)
mov rdi, 0			;;(*rdi will be used to point to the next address in the vector*)

mov r9, 4
;; (*start of loop to copy parameters to the new allocated vector*)
copy_params_loop_888483189:
cmp rdi, rcx
je after_params_copy_888483189
mov rsi, [rbp + 8 * r9]			;;(*now rsi points to the next parameter on the stack*)
mov [rdx + 8*rdi], rsi			;;(*copying the parameter to the new allocated vector*)
inc rdi
inc r9
jmp copy_params_loop_888483189
;; (*now rdx points to the new vector to be added to ext_env*)
;; (*mov 0 to all neccessary registers*)
after_params_copy_888483189:
mov rcx, 0
mov rdi, 0
mov rsi, 0
;; (*now we need to create ext_env by copying env and adding the new vector*)
MALLOC rbx, 16			;;(*rbx points to a new allocated space for ext_env*)
mov [rbx], rdx			;;(*coping the new vector to ext_env[0]*)
mov rsi, [rbp + 8 * 2]			;;(*rsi points to current env*)
mov rcx, 1			;;(*rcx is the loop counter*)
mov r9, 0			;;(*r9 will be used to point to the next vector in current env to be copied*)
mov rdi, 1			;;(*rdi will be used to point to the next address in ext_env*)
mov r8, 0
;; (*start of loop for copying env[i] to ext_env[i+1]*)
copy_env_loop_888483189:
cmp r9, rcx
je after_env_copy_888483189
mov r8, [rsi + 8 * r9]			;;(*r8 points to the next vector int current env to be copied*) 
mov [rbx + 8 * rdi], r8			;;(*copying the pointer to the vector from env to ext_env*)
inc r9
inc rdi
jmp copy_env_loop_888483189
after_env_copy_888483189:

MAKE_CLOSURE(rax, rbx, Lcode_888483189)
jmp Lcont_888483189
Lcode_888483189:
push rbp
mov rbp, rsp

mov qword rax, [rbp + 32]
MALLOC r11, 8
mov qword [r11], rax
mov rax, r11

mov qword [rbp + 32], rax
mov rax, SOB_VOID_ADDRESS




mov rsi, [rbp + 8 * 3]			;; (*rsi holds the number of parametres on the stack*)
lea rsi, [rsi * 8]
inc rsi			;;(*rsi holds the number of bytes to allocate for the new vector which is number_of_params + 1 (for magic)*)
MALLOC rdx, rsi			;; (*now rdx points to the allocated memory for the new vector*)
mov rcx, [rbp + 8 * 3]
inc rcx			;;(*rcx holds the number of parametres on the stack + 1 (for magic),  rcx is the loop counter*)
mov rdi, 0			;;(*rdi will be used to point to the next address in the vector*)

mov r9, 4
;; (*start of loop to copy parameters to the new allocated vector*)
copy_params_loop_929852288:
cmp rdi, rcx
je after_params_copy_929852288
mov rsi, [rbp + 8 * r9]			;;(*now rsi points to the next parameter on the stack*)
mov [rdx + 8*rdi], rsi			;;(*copying the parameter to the new allocated vector*)
inc rdi
inc r9
jmp copy_params_loop_929852288
;; (*now rdx points to the new vector to be added to ext_env*)
;; (*mov 0 to all neccessary registers*)
after_params_copy_929852288:
mov rcx, 0
mov rdi, 0
mov rsi, 0
;; (*now we need to create ext_env by copying env and adding the new vector*)
MALLOC rbx, 24			;;(*rbx points to a new allocated space for ext_env*)
mov [rbx], rdx			;;(*coping the new vector to ext_env[0]*)
mov rsi, [rbp + 8 * 2]			;;(*rsi points to current env*)
mov rcx, 2			;;(*rcx is the loop counter*)
mov r9, 0			;;(*r9 will be used to point to the next vector in current env to be copied*)
mov rdi, 1			;;(*rdi will be used to point to the next address in ext_env*)
mov r8, 0
;; (*start of loop for copying env[i] to ext_env[i+1]*)
copy_env_loop_929852288:
cmp r9, rcx
je after_env_copy_929852288
mov r8, [rsi + 8 * r9]			;;(*r8 points to the next vector int current env to be copied*) 
mov [rbx + 8 * rdi], r8			;;(*copying the pointer to the vector from env to ext_env*)
inc r9
inc rdi
jmp copy_env_loop_929852288
after_env_copy_929852288:

MAKE_CLOSURE(rax, rbx, Lcode_929852288)
jmp Lcont_929852288
Lcode_929852288:
push rbp
mov rbp, rsp

push SOB_NIL_ADDRESS		 ; comment nadav

mov qword rax, [rbp + 40]

push rax

push 2
mov rax, qword [rbp + 16]
mov rax, qword [rax + 8]
mov rax, qword [rax + 0]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
after_applic_468792198:

cmp rax, SOB_FALSE_ADDRESS
je Lelse_402949384
mov rax, const_tbl+4

jmp Lexit_267491446
Lelse_402949384:

push SOB_NIL_ADDRESS		 ; comment nadav


push SOB_NIL_ADDRESS		 ; comment nadav


push SOB_NIL_ADDRESS		 ; comment nadav

mov qword rax, [rbp + 40]

push rax

push 2
mov rax, qword [rbp + 16]
mov rax, qword [rax + 8]
mov rax, qword [rax + 32]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
after_applic_44463351:

push rax

mov qword rax, [rbp + 32]

push rax

push 3
mov rax, qword [rbp + 16]
mov rax, qword [rax + 8]
mov rax, qword [rax + 8]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
after_applic_57534567:

cmp rax, SOB_FALSE_ADDRESS
jne Lexit_991642384

push SOB_NIL_ADDRESS		 ; comment nadav


push SOB_NIL_ADDRESS		 ; comment nadav

mov qword rax, [rbp + 40]

push rax

push 2
mov rax, qword [rbp + 16]
mov rax, qword [rax + 8]
mov rax, qword [rax + 32]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
after_applic_698633168:

push rax

mov qword rax, [rbp + 32]

push rax

push 3
mov rax, qword [rbp + 16]
mov rax, qword [rax + 8]
mov rax, qword [rax + 16]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
after_applic_572162651:

Lexit_991642384:

push rax

push 2
mov rax, qword [rbp + 16]
mov rax, qword [rax + 8]
mov rax, qword [rax + 24]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
after_applic_725956947:

cmp rax, SOB_FALSE_ADDRESS
je Lelse_255480485

push SOB_NIL_ADDRESS		 ; comment nadav


push SOB_NIL_ADDRESS		 ; comment nadav

mov qword rax, [rbp + 40]

push rax

push 2
mov rax, qword [rbp + 16]
mov rax, qword [rax + 8]
mov rax, qword [rax + 40]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
after_applic_763661805:

push rax


push SOB_NIL_ADDRESS		 ; comment nadav

mov qword rax, [rbp + 40]

push rax

push 2
mov rax, qword [rbp + 16]
mov rax, qword [rax + 8]
mov rax, qword [rax + 32]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
after_applic_976927359:

push rax

push 3
mov rax, qword [rbp + 16]
mov rax, qword [rax + 0]
mov rax, qword [rax + 0]

mov rax, qword [rax]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
after_applic_698193242:

jmp Lexit_77108180
Lelse_255480485:
mov rax, const_tbl+2

Lexit_77108180:

Lexit_267491446:

leave
ret
Lcont_929852288:


push rax
mov qword rax, [rbp + 32]

pop qword [rax]
mov rax, SOB_VOID_ADDRESS


mov rax, 1


leave
ret
Lcont_888483189:


push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
after_applic_284101271:

leave
ret
Lcont_798031681:


push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
after_applic_260383377:

mov [fvar_tbl + 8*45], rax
mov rax, SOB_VOID_ADDRESS
	call write_sob_if_not_void


push SOB_NIL_ADDRESS		 ; comment nadav

mov rax, qword [fvar_tbl + 8*27]

push rax

push 2
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode_877236981)
jmp Lcont_877236981
Lcode_877236981:
push rbp
mov rbp, rsp

mov rsi, [rbp + 8 * 3]			;; (*rsi holds the number of parametres on the stack*)
lea rsi, [rsi * 8]
inc rsi			;;(*rsi holds the number of bytes to allocate for the new vector which is number_of_params + 1 (for magic)*)
MALLOC rdx, rsi			;; (*now rdx points to the allocated memory for the new vector*)
mov rcx, [rbp + 8 * 3]
inc rcx			;;(*rcx holds the number of parametres on the stack + 1 (for magic),  rcx is the loop counter*)
mov rdi, 0			;;(*rdi will be used to point to the next address in the vector*)

mov r9, 4
;; (*start of loop to copy parameters to the new allocated vector*)
copy_params_loop_34268921:
cmp rdi, rcx
je after_params_copy_34268921
mov rsi, [rbp + 8 * r9]			;;(*now rsi points to the next parameter on the stack*)
mov [rdx + 8*rdi], rsi			;;(*copying the parameter to the new allocated vector*)
inc rdi
inc r9
jmp copy_params_loop_34268921
;; (*now rdx points to the new vector to be added to ext_env*)
;; (*mov 0 to all neccessary registers*)
after_params_copy_34268921:
mov rcx, 0
mov rdi, 0
mov rsi, 0
;; (*now we need to create ext_env by copying env and adding the new vector*)
MALLOC rbx, 16			;;(*rbx points to a new allocated space for ext_env*)
mov [rbx], rdx			;;(*coping the new vector to ext_env[0]*)
mov rsi, [rbp + 8 * 2]			;;(*rsi points to current env*)
mov rcx, 1			;;(*rcx is the loop counter*)
mov r9, 0			;;(*r9 will be used to point to the next vector in current env to be copied*)
mov rdi, 1			;;(*rdi will be used to point to the next address in ext_env*)
mov r8, 0
;; (*start of loop for copying env[i] to ext_env[i+1]*)
copy_env_loop_34268921:
cmp r9, rcx
je after_env_copy_34268921
mov r8, [rsi + 8 * r9]			;;(*r8 points to the next vector int current env to be copied*) 
mov [rbx + 8 * rdi], r8			;;(*copying the pointer to the vector from env to ext_env*)
inc r9
inc rdi
jmp copy_env_loop_34268921
after_env_copy_34268921:

MAKE_CLOSURE(rax, rbx, Lcode_34268921)
jmp Lcont_34268921
Lcode_34268921:
push rbp
mov rbp, rsp

push SOB_NIL_ADDRESS		 ; comment nadav

mov rax, const_tbl+41

push rax

mov qword rax, [rbp + 32]

push rax

push 3
mov rax, qword [rbp + 16]
mov rax, qword [rax + 0]
mov rax, qword [rax + 0]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
after_applic_974805207:

leave
ret
Lcont_34268921:


leave
ret
Lcont_877236981:


push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
after_applic_746869368:

mov [fvar_tbl + 8*46], rax
mov rax, SOB_VOID_ADDRESS
	call write_sob_if_not_void


push SOB_NIL_ADDRESS		 ; comment nadav

mov rax, qword [fvar_tbl + 8*24]

push rax

mov rax, qword [fvar_tbl + 8*26]

push rax

mov rax, qword [fvar_tbl + 8*10]

push rax

mov rax, qword [fvar_tbl + 8*11]

push rax

push 5
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode_926039712)
jmp Lcont_926039712
Lcode_926039712:
push rbp
mov rbp, rsp

mov rsi, [rbp + 8 * 3]			;; (*rsi holds the number of parametres on the stack*)
lea rsi, [rsi * 8]
inc rsi			;;(*rsi holds the number of bytes to allocate for the new vector which is number_of_params + 1 (for magic)*)
MALLOC rdx, rsi			;; (*now rdx points to the allocated memory for the new vector*)
mov rcx, [rbp + 8 * 3]
inc rcx			;;(*rcx holds the number of parametres on the stack + 1 (for magic),  rcx is the loop counter*)
mov rdi, 0			;;(*rdi will be used to point to the next address in the vector*)

mov r9, 4
;; (*start of loop to copy parameters to the new allocated vector*)
copy_params_loop_929236965:
cmp rdi, rcx
je after_params_copy_929236965
mov rsi, [rbp + 8 * r9]			;;(*now rsi points to the next parameter on the stack*)
mov [rdx + 8*rdi], rsi			;;(*copying the parameter to the new allocated vector*)
inc rdi
inc r9
jmp copy_params_loop_929236965
;; (*now rdx points to the new vector to be added to ext_env*)
;; (*mov 0 to all neccessary registers*)
after_params_copy_929236965:
mov rcx, 0
mov rdi, 0
mov rsi, 0
;; (*now we need to create ext_env by copying env and adding the new vector*)
MALLOC rbx, 16			;;(*rbx points to a new allocated space for ext_env*)
mov [rbx], rdx			;;(*coping the new vector to ext_env[0]*)
mov rsi, [rbp + 8 * 2]			;;(*rsi points to current env*)
mov rcx, 1			;;(*rcx is the loop counter*)
mov r9, 0			;;(*r9 will be used to point to the next vector in current env to be copied*)
mov rdi, 1			;;(*rdi will be used to point to the next address in ext_env*)
mov r8, 0
;; (*start of loop for copying env[i] to ext_env[i+1]*)
copy_env_loop_929236965:
cmp r9, rcx
je after_env_copy_929236965
mov r8, [rsi + 8 * r9]			;;(*r8 points to the next vector int current env to be copied*) 
mov [rbx + 8 * rdi], r8			;;(*copying the pointer to the vector from env to ext_env*)
inc r9
inc rdi
jmp copy_env_loop_929236965
after_env_copy_929236965:

MAKE_CLOSURE(rax, rbx, Lcode_929236965)
jmp Lcont_929236965
Lcode_929236965:
push rbp
mov rbp, rsp

push SOB_NIL_ADDRESS		 ; comment nadav

mov rax, const_tbl+23

push rax

push 2

mov rsi, [rbp + 8 * 3]			;; (*rsi holds the number of parametres on the stack*)
lea rsi, [rsi * 8]
inc rsi			;;(*rsi holds the number of bytes to allocate for the new vector which is number_of_params + 1 (for magic)*)
MALLOC rdx, rsi			;; (*now rdx points to the allocated memory for the new vector*)
mov rcx, [rbp + 8 * 3]
inc rcx			;;(*rcx holds the number of parametres on the stack + 1 (for magic),  rcx is the loop counter*)
mov rdi, 0			;;(*rdi will be used to point to the next address in the vector*)

mov r9, 4
;; (*start of loop to copy parameters to the new allocated vector*)
copy_params_loop_946550165:
cmp rdi, rcx
je after_params_copy_946550165
mov rsi, [rbp + 8 * r9]			;;(*now rsi points to the next parameter on the stack*)
mov [rdx + 8*rdi], rsi			;;(*copying the parameter to the new allocated vector*)
inc rdi
inc r9
jmp copy_params_loop_946550165
;; (*now rdx points to the new vector to be added to ext_env*)
;; (*mov 0 to all neccessary registers*)
after_params_copy_946550165:
mov rcx, 0
mov rdi, 0
mov rsi, 0
;; (*now we need to create ext_env by copying env and adding the new vector*)
MALLOC rbx, 24			;;(*rbx points to a new allocated space for ext_env*)
mov [rbx], rdx			;;(*coping the new vector to ext_env[0]*)
mov rsi, [rbp + 8 * 2]			;;(*rsi points to current env*)
mov rcx, 2			;;(*rcx is the loop counter*)
mov r9, 0			;;(*r9 will be used to point to the next vector in current env to be copied*)
mov rdi, 1			;;(*rdi will be used to point to the next address in ext_env*)
mov r8, 0
;; (*start of loop for copying env[i] to ext_env[i+1]*)
copy_env_loop_946550165:
cmp r9, rcx
je after_env_copy_946550165
mov r8, [rsi + 8 * r9]			;;(*r8 points to the next vector int current env to be copied*) 
mov [rbx + 8 * rdi], r8			;;(*copying the pointer to the vector from env to ext_env*)
inc r9
inc rdi
jmp copy_env_loop_946550165
after_env_copy_946550165:

MAKE_CLOSURE(rax, rbx, Lcode_946550165)
jmp Lcont_946550165
Lcode_946550165:
push rbp
mov rbp, rsp

mov qword rax, [rbp + 32]
MALLOC r11, 8
mov qword [r11], rax
mov rax, r11

mov qword [rbp + 32], rax
mov rax, SOB_VOID_ADDRESS




mov rsi, [rbp + 8 * 3]			;; (*rsi holds the number of parametres on the stack*)
lea rsi, [rsi * 8]
inc rsi			;;(*rsi holds the number of bytes to allocate for the new vector which is number_of_params + 1 (for magic)*)
MALLOC rdx, rsi			;; (*now rdx points to the allocated memory for the new vector*)
mov rcx, [rbp + 8 * 3]
inc rcx			;;(*rcx holds the number of parametres on the stack + 1 (for magic),  rcx is the loop counter*)
mov rdi, 0			;;(*rdi will be used to point to the next address in the vector*)

mov r9, 4
;; (*start of loop to copy parameters to the new allocated vector*)
copy_params_loop_795791525:
cmp rdi, rcx
je after_params_copy_795791525
mov rsi, [rbp + 8 * r9]			;;(*now rsi points to the next parameter on the stack*)
mov [rdx + 8*rdi], rsi			;;(*copying the parameter to the new allocated vector*)
inc rdi
inc r9
jmp copy_params_loop_795791525
;; (*now rdx points to the new vector to be added to ext_env*)
;; (*mov 0 to all neccessary registers*)
after_params_copy_795791525:
mov rcx, 0
mov rdi, 0
mov rsi, 0
;; (*now we need to create ext_env by copying env and adding the new vector*)
MALLOC rbx, 32			;;(*rbx points to a new allocated space for ext_env*)
mov [rbx], rdx			;;(*coping the new vector to ext_env[0]*)
mov rsi, [rbp + 8 * 2]			;;(*rsi points to current env*)
mov rcx, 3			;;(*rcx is the loop counter*)
mov r9, 0			;;(*r9 will be used to point to the next vector in current env to be copied*)
mov rdi, 1			;;(*rdi will be used to point to the next address in ext_env*)
mov r8, 0
;; (*start of loop for copying env[i] to ext_env[i+1]*)
copy_env_loop_795791525:
cmp r9, rcx
je after_env_copy_795791525
mov r8, [rsi + 8 * r9]			;;(*r8 points to the next vector int current env to be copied*) 
mov [rbx + 8 * rdi], r8			;;(*copying the pointer to the vector from env to ext_env*)
inc r9
inc rdi
jmp copy_env_loop_795791525
after_env_copy_795791525:

MAKE_CLOSURE(rax, rbx, Lcode_795791525)
jmp Lcont_795791525
Lcode_795791525:
push rbp
mov rbp, rsp

push SOB_NIL_ADDRESS		 ; comment nadav

mov rax, const_tbl+41

push rax

mov qword rax, [rbp + 32]

push rax

push 3
mov rax, qword [rbp + 16]
mov rax, qword [rax + 16]
mov rax, qword [rax + 16]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
after_applic_925883755:

cmp rax, SOB_FALSE_ADDRESS
je Lelse_954345019
mov qword rax, [rbp + 40]

jmp Lexit_358483680
Lelse_954345019:

push SOB_NIL_ADDRESS		 ; comment nadav


push SOB_NIL_ADDRESS		 ; comment nadav

mov qword rax, [rbp + 40]

push rax


push SOB_NIL_ADDRESS		 ; comment nadav

mov qword rax, [rbp + 32]

push rax

mov rax, qword [rbp + 16]
mov rax, qword [rax + 8]
mov rax, qword [rax + 0]

push rax

push 3
mov rax, qword [rbp + 16]
mov rax, qword [rax + 16]
mov rax, qword [rax + 0]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
after_applic_369777082:

push rax

push 3
mov rax, qword [fvar_tbl + 8*33]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
after_applic_222968330:

push rax


push SOB_NIL_ADDRESS		 ; comment nadav

mov rax, const_tbl+32

push rax

mov qword rax, [rbp + 32]

push rax

push 3
mov rax, qword [rbp + 16]
mov rax, qword [rax + 16]
mov rax, qword [rax + 24]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
after_applic_704528317:

push rax

push 3
mov rax, qword [rbp + 16]
mov rax, qword [rax + 0]
mov rax, qword [rax + 0]

mov rax, qword [rax]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
after_applic_399233363:

Lexit_358483680:

leave
ret
Lcont_795791525:


push rax
mov qword rax, [rbp + 32]

pop qword [rax]
mov rax, SOB_VOID_ADDRESS



push SOB_NIL_ADDRESS		 ; comment nadav

mov rax, const_tbl+1

push rax


push SOB_NIL_ADDRESS		 ; comment nadav

mov rax, const_tbl+32

push rax


push SOB_NIL_ADDRESS		 ; comment nadav

mov rax, qword [rbp + 16]
mov rax, qword [rax + 0]
mov rax, qword [rax + 0]

push rax

push 2
mov rax, qword [rbp + 16]
mov rax, qword [rax + 8]
mov rax, qword [rax + 8]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
after_applic_491303945:

push rax

push 3
mov rax, qword [rbp + 16]
mov rax, qword [rax + 8]
mov rax, qword [rax + 24]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
after_applic_885606344:

push rax

push 3
mov qword rax, [rbp + 32]

mov rax, qword [rax]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
after_applic_988084389:



leave
ret
Lcont_946550165:


push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
after_applic_113414598:

leave
ret
Lcont_929236965:


leave
ret
Lcont_926039712:


push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
after_applic_996131318:

mov [fvar_tbl + 8*47], rax
mov rax, SOB_VOID_ADDRESS
	call write_sob_if_not_void


push SOB_NIL_ADDRESS		 ; comment nadav

mov rax, qword [fvar_tbl + 8*19]

push rax

mov rax, qword [fvar_tbl + 8*29]

push rax

mov rax, qword [fvar_tbl + 8*28]

push rax

mov rax, qword [fvar_tbl + 8*21]

push rax

mov rax, qword [fvar_tbl + 8*7]

push rax

mov rax, qword [fvar_tbl + 8*5]

push rax

mov rax, qword [fvar_tbl + 8*3]

push rax

mov rax, qword [fvar_tbl + 8*1]

push rax

mov rax, qword [fvar_tbl + 8*2]

push rax

mov rax, qword [fvar_tbl + 8*47]

push rax

mov rax, qword [fvar_tbl + 8*27]

push rax

push 12
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode_469797467)
jmp Lcont_469797467
Lcode_469797467:
push rbp
mov rbp, rsp

push SOB_NIL_ADDRESS		 ; comment nadav

mov rax, const_tbl+23

push rax

push 2

mov rsi, [rbp + 8 * 3]			;; (*rsi holds the number of parametres on the stack*)
lea rsi, [rsi * 8]
inc rsi			;;(*rsi holds the number of bytes to allocate for the new vector which is number_of_params + 1 (for magic)*)
MALLOC rdx, rsi			;; (*now rdx points to the allocated memory for the new vector*)
mov rcx, [rbp + 8 * 3]
inc rcx			;;(*rcx holds the number of parametres on the stack + 1 (for magic),  rcx is the loop counter*)
mov rdi, 0			;;(*rdi will be used to point to the next address in the vector*)

mov r9, 4
;; (*start of loop to copy parameters to the new allocated vector*)
copy_params_loop_114123571:
cmp rdi, rcx
je after_params_copy_114123571
mov rsi, [rbp + 8 * r9]			;;(*now rsi points to the next parameter on the stack*)
mov [rdx + 8*rdi], rsi			;;(*copying the parameter to the new allocated vector*)
inc rdi
inc r9
jmp copy_params_loop_114123571
;; (*now rdx points to the new vector to be added to ext_env*)
;; (*mov 0 to all neccessary registers*)
after_params_copy_114123571:
mov rcx, 0
mov rdi, 0
mov rsi, 0
;; (*now we need to create ext_env by copying env and adding the new vector*)
MALLOC rbx, 16			;;(*rbx points to a new allocated space for ext_env*)
mov [rbx], rdx			;;(*coping the new vector to ext_env[0]*)
mov rsi, [rbp + 8 * 2]			;;(*rsi points to current env*)
mov rcx, 1			;;(*rcx is the loop counter*)
mov r9, 0			;;(*r9 will be used to point to the next vector in current env to be copied*)
mov rdi, 1			;;(*rdi will be used to point to the next address in ext_env*)
mov r8, 0
;; (*start of loop for copying env[i] to ext_env[i+1]*)
copy_env_loop_114123571:
cmp r9, rcx
je after_env_copy_114123571
mov r8, [rsi + 8 * r9]			;;(*r8 points to the next vector int current env to be copied*) 
mov [rbx + 8 * rdi], r8			;;(*copying the pointer to the vector from env to ext_env*)
inc r9
inc rdi
jmp copy_env_loop_114123571
after_env_copy_114123571:

MAKE_CLOSURE(rax, rbx, Lcode_114123571)
jmp Lcont_114123571
Lcode_114123571:
push rbp
mov rbp, rsp

mov qword rax, [rbp + 32]
MALLOC r11, 8
mov qword [r11], rax
mov rax, r11

mov qword [rbp + 32], rax
mov rax, SOB_VOID_ADDRESS




mov rsi, [rbp + 8 * 3]			;; (*rsi holds the number of parametres on the stack*)
lea rsi, [rsi * 8]
inc rsi			;;(*rsi holds the number of bytes to allocate for the new vector which is number_of_params + 1 (for magic)*)
MALLOC rdx, rsi			;; (*now rdx points to the allocated memory for the new vector*)
mov rcx, [rbp + 8 * 3]
inc rcx			;;(*rcx holds the number of parametres on the stack + 1 (for magic),  rcx is the loop counter*)
mov rdi, 0			;;(*rdi will be used to point to the next address in the vector*)

mov r9, 4
;; (*start of loop to copy parameters to the new allocated vector*)
copy_params_loop_742945834:
cmp rdi, rcx
je after_params_copy_742945834
mov rsi, [rbp + 8 * r9]			;;(*now rsi points to the next parameter on the stack*)
mov [rdx + 8*rdi], rsi			;;(*copying the parameter to the new allocated vector*)
inc rdi
inc r9
jmp copy_params_loop_742945834
;; (*now rdx points to the new vector to be added to ext_env*)
;; (*mov 0 to all neccessary registers*)
after_params_copy_742945834:
mov rcx, 0
mov rdi, 0
mov rsi, 0
;; (*now we need to create ext_env by copying env and adding the new vector*)
MALLOC rbx, 24			;;(*rbx points to a new allocated space for ext_env*)
mov [rbx], rdx			;;(*coping the new vector to ext_env[0]*)
mov rsi, [rbp + 8 * 2]			;;(*rsi points to current env*)
mov rcx, 2			;;(*rcx is the loop counter*)
mov r9, 0			;;(*r9 will be used to point to the next vector in current env to be copied*)
mov rdi, 1			;;(*rdi will be used to point to the next address in ext_env*)
mov r8, 0
;; (*start of loop for copying env[i] to ext_env[i+1]*)
copy_env_loop_742945834:
cmp r9, rcx
je after_env_copy_742945834
mov r8, [rsi + 8 * r9]			;;(*r8 points to the next vector int current env to be copied*) 
mov [rbx + 8 * rdi], r8			;;(*copying the pointer to the vector from env to ext_env*)
inc r9
inc rdi
jmp copy_env_loop_742945834
after_env_copy_742945834:

MAKE_CLOSURE(rax, rbx, Lcode_742945834)
jmp Lcont_742945834
Lcode_742945834:
push rbp
mov rbp, rsp

push SOB_NIL_ADDRESS		 ; comment nadav

mov qword rax, [rbp + 32]

push rax

push 2
mov rax, qword [rbp + 16]
mov rax, qword [rax + 8]
mov rax, qword [rax + 16]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
after_applic_338771299:

cmp rax, SOB_FALSE_ADDRESS
je Lelse_98695905

push SOB_NIL_ADDRESS		 ; comment nadav

mov qword rax, [rbp + 40]

push rax

push 2
mov rax, qword [rbp + 16]
mov rax, qword [rax + 8]
mov rax, qword [rax + 16]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
after_applic_514988712:

cmp rax, SOB_FALSE_ADDRESS
je Lelse_236572

push SOB_NIL_ADDRESS		 ; comment nadav

mov qword rax, [rbp + 40]

push rax

mov qword rax, [rbp + 32]

push rax

push 3
mov rax, qword [rbp + 16]
mov rax, qword [rax + 8]
mov rax, qword [rax + 0]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
after_applic_933494370:

jmp Lexit_528306746
Lelse_236572:
mov rax, const_tbl+2

Lexit_528306746:

jmp Lexit_829527378
Lelse_98695905:
mov rax, const_tbl+2

Lexit_829527378:

cmp rax, SOB_FALSE_ADDRESS
jne Lexit_325241101

push SOB_NIL_ADDRESS		 ; comment nadav

mov qword rax, [rbp + 32]

push rax

push 2
mov rax, qword [rbp + 16]
mov rax, qword [rax + 8]
mov rax, qword [rax + 24]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
after_applic_151124289:

cmp rax, SOB_FALSE_ADDRESS
je Lelse_967574633

push SOB_NIL_ADDRESS		 ; comment nadav

mov qword rax, [rbp + 40]

push rax

push 2
mov rax, qword [rbp + 16]
mov rax, qword [rax + 8]
mov rax, qword [rax + 24]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
after_applic_538829788:

cmp rax, SOB_FALSE_ADDRESS
je Lelse_691104538

push SOB_NIL_ADDRESS		 ; comment nadav

mov qword rax, [rbp + 40]

push rax

mov qword rax, [rbp + 32]

push rax

push 3
mov rax, qword [rbp + 16]
mov rax, qword [rax + 8]
mov rax, qword [rax + 0]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
after_applic_621109403:

jmp Lexit_541256566
Lelse_691104538:
mov rax, const_tbl+2

Lexit_541256566:

jmp Lexit_337831655
Lelse_967574633:
mov rax, const_tbl+2

Lexit_337831655:

cmp rax, SOB_FALSE_ADDRESS
jne Lexit_325241101

push SOB_NIL_ADDRESS		 ; comment nadav

mov qword rax, [rbp + 32]

push rax

push 2
mov rax, qword [rbp + 16]
mov rax, qword [rax + 8]
mov rax, qword [rax + 32]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
after_applic_421021563:

cmp rax, SOB_FALSE_ADDRESS
je Lelse_578098865

push SOB_NIL_ADDRESS		 ; comment nadav

mov qword rax, [rbp + 40]

push rax

push 2
mov rax, qword [rbp + 16]
mov rax, qword [rax + 8]
mov rax, qword [rax + 32]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
after_applic_256182561:

cmp rax, SOB_FALSE_ADDRESS
je Lelse_384027154

push SOB_NIL_ADDRESS		 ; comment nadav


push SOB_NIL_ADDRESS		 ; comment nadav

mov qword rax, [rbp + 40]

push rax

push 2
mov rax, qword [rbp + 16]
mov rax, qword [rax + 8]
mov rax, qword [rax + 64]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
after_applic_226304471:

push rax


push SOB_NIL_ADDRESS		 ; comment nadav

mov qword rax, [rbp + 32]

push rax

push 2
mov rax, qword [rbp + 16]
mov rax, qword [rax + 8]
mov rax, qword [rax + 64]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
after_applic_303242831:

push rax

push 3
mov rax, qword [rbp + 16]
mov rax, qword [rax + 0]
mov rax, qword [rax + 0]

mov rax, qword [rax]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
after_applic_777214754:

cmp rax, SOB_FALSE_ADDRESS
je Lelse_483417528

push SOB_NIL_ADDRESS		 ; comment nadav


push SOB_NIL_ADDRESS		 ; comment nadav

mov qword rax, [rbp + 40]

push rax

push 2
mov rax, qword [rbp + 16]
mov rax, qword [rax + 8]
mov rax, qword [rax + 72]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
after_applic_736646258:

push rax


push SOB_NIL_ADDRESS		 ; comment nadav

mov qword rax, [rbp + 32]

push rax

push 2
mov rax, qword [rbp + 16]
mov rax, qword [rax + 8]
mov rax, qword [rax + 72]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
after_applic_991360546:

push rax

push 3
mov rax, qword [rbp + 16]
mov rax, qword [rax + 0]
mov rax, qword [rax + 0]

mov rax, qword [rax]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
after_applic_514664874:

jmp Lexit_514260817
Lelse_483417528:
mov rax, const_tbl+2

Lexit_514260817:

jmp Lexit_116195277
Lelse_384027154:
mov rax, const_tbl+2

Lexit_116195277:

jmp Lexit_905984946
Lelse_578098865:
mov rax, const_tbl+2

Lexit_905984946:

cmp rax, SOB_FALSE_ADDRESS
jne Lexit_325241101

push SOB_NIL_ADDRESS		 ; comment nadav

mov qword rax, [rbp + 32]

push rax

push 2
mov rax, qword [rbp + 16]
mov rax, qword [rax + 8]
mov rax, qword [rax + 40]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
after_applic_607713823:

cmp rax, SOB_FALSE_ADDRESS
je Lelse_802660656

push SOB_NIL_ADDRESS		 ; comment nadav

mov qword rax, [rbp + 40]

push rax

push 2
mov rax, qword [rbp + 16]
mov rax, qword [rax + 8]
mov rax, qword [rax + 40]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
after_applic_361404286:

cmp rax, SOB_FALSE_ADDRESS
je Lelse_148094636

push SOB_NIL_ADDRESS		 ; comment nadav


push SOB_NIL_ADDRESS		 ; comment nadav

mov qword rax, [rbp + 40]

push rax

push 2
mov rax, qword [rbp + 16]
mov rax, qword [rax + 8]
mov rax, qword [rax + 80]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
after_applic_23684769:

push rax


push SOB_NIL_ADDRESS		 ; comment nadav

mov qword rax, [rbp + 32]

push rax

push 2
mov rax, qword [rbp + 16]
mov rax, qword [rax + 8]
mov rax, qword [rax + 80]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
after_applic_986630149:

push rax

push 3
mov rax, qword [rbp + 16]
mov rax, qword [rax + 8]
mov rax, qword [rax + 0]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
after_applic_47888016:

jmp Lexit_613964162
Lelse_148094636:
mov rax, const_tbl+2

Lexit_613964162:

jmp Lexit_124999081
Lelse_802660656:
mov rax, const_tbl+2

Lexit_124999081:

cmp rax, SOB_FALSE_ADDRESS
jne Lexit_325241101

push SOB_NIL_ADDRESS		 ; comment nadav

mov qword rax, [rbp + 32]

push rax

push 2
mov rax, qword [rbp + 16]
mov rax, qword [rax + 8]
mov rax, qword [rax + 48]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
after_applic_139596420:

cmp rax, SOB_FALSE_ADDRESS
je Lelse_403884646

push SOB_NIL_ADDRESS		 ; comment nadav

mov qword rax, [rbp + 40]

push rax

push 2
mov rax, qword [rbp + 16]
mov rax, qword [rax + 8]
mov rax, qword [rax + 48]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
after_applic_650329590:

cmp rax, SOB_FALSE_ADDRESS
je Lelse_854160036

push SOB_NIL_ADDRESS		 ; comment nadav


push SOB_NIL_ADDRESS		 ; comment nadav

mov qword rax, [rbp + 40]

push rax

push 2
mov rax, qword [rbp + 16]
mov rax, qword [rax + 8]
mov rax, qword [rax + 8]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
after_applic_810501363:

push rax


push SOB_NIL_ADDRESS		 ; comment nadav

mov qword rax, [rbp + 32]

push rax

push 2
mov rax, qword [rbp + 16]
mov rax, qword [rax + 8]
mov rax, qword [rax + 8]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
after_applic_182772876:

push rax

push 3
mov rax, qword [rbp + 16]
mov rax, qword [rax + 0]
mov rax, qword [rax + 0]

mov rax, qword [rax]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
after_applic_264763085:

jmp Lexit_465023326
Lelse_854160036:
mov rax, const_tbl+2

Lexit_465023326:

jmp Lexit_565526397
Lelse_403884646:
mov rax, const_tbl+2

Lexit_565526397:

cmp rax, SOB_FALSE_ADDRESS
jne Lexit_325241101

push SOB_NIL_ADDRESS		 ; comment nadav

mov qword rax, [rbp + 40]

push rax

mov qword rax, [rbp + 32]

push rax

push 3
mov rax, qword [rbp + 16]
mov rax, qword [rax + 8]
mov rax, qword [rax + 56]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
after_applic_380853348:

Lexit_325241101:

leave
ret
Lcont_742945834:


push rax
mov qword rax, [rbp + 32]

pop qword [rax]
mov rax, SOB_VOID_ADDRESS


mov qword rax, [rbp + 32]

mov rax, qword [rax]



leave
ret
Lcont_114123571:


push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
after_applic_45872671:

leave
ret
Lcont_469797467:


push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
after_applic_425882962:

mov [fvar_tbl + 8*48], rax
mov rax, SOB_VOID_ADDRESS
	call write_sob_if_not_void


push SOB_NIL_ADDRESS		 ; comment nadav

mov rax, const_tbl+78

push rax

push 2
mov rax, qword [fvar_tbl + 8*28]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
after_applic_831201747:

	call write_sob_if_not_void

	mov rax, 0
	add rsp, 4*8
	pop rbp
	ret

car:
    push rbp
    mov rbp, rsp
    mov rsi, PVAR(0)    ; now rsi points to the possible pair
    mov rax, [rsi + 1]   ; now rax points to the car of the pair
    leave
    ret

is_boolean:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov sil, byte [rsi]

    cmp sil, T_BOOL
    jne .wrong_type
    mov rax, SOB_TRUE_ADDRESS
    jmp .return

.wrong_type:
    mov rax, SOB_FALSE_ADDRESS
.return:
    leave
    ret

is_float:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov sil, byte [rsi]

    cmp sil, T_FLOAT
    jne .wrong_type
    mov rax, SOB_TRUE_ADDRESS
    jmp .return

.wrong_type:
    mov rax, SOB_FALSE_ADDRESS
.return:
    leave
    ret

is_integer:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov sil, byte [rsi]

    cmp sil, T_INTEGER
    jne .wrong_type
    mov rax, SOB_TRUE_ADDRESS
    jmp .return

.wrong_type:
    mov rax, SOB_FALSE_ADDRESS
.return:
    leave
    ret

is_pair:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov sil, byte [rsi]

    cmp sil, T_PAIR
    jne .wrong_type
    mov rax, SOB_TRUE_ADDRESS
    jmp .return

.wrong_type:
    mov rax, SOB_FALSE_ADDRESS
.return:
    leave
    ret

is_null:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov sil, byte [rsi]

    cmp sil, T_NIL
    jne .wrong_type
    mov rax, SOB_TRUE_ADDRESS
    jmp .return

.wrong_type:
    mov rax, SOB_FALSE_ADDRESS
.return:
    leave
    ret

is_char:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov sil, byte [rsi]

    cmp sil, T_CHAR
    jne .wrong_type
    mov rax, SOB_TRUE_ADDRESS
    jmp .return

.wrong_type:
    mov rax, SOB_FALSE_ADDRESS
.return:
    leave
    ret

is_string:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov sil, byte [rsi]

    cmp sil, T_STRING
    jne .wrong_type
    mov rax, SOB_TRUE_ADDRESS
    jmp .return

.wrong_type:
    mov rax, SOB_FALSE_ADDRESS
.return:
    leave
    ret

is_procedure:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov sil, byte [rsi]

    cmp sil, T_CLOSURE
    jne .wrong_type
    mov rax, SOB_TRUE_ADDRESS
    jmp .return

.wrong_type:
    mov rax, SOB_FALSE_ADDRESS
.return:
    leave
    ret

is_symbol:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov sil, byte [rsi]

    cmp sil, T_SYMBOL
    jne .wrong_type
    mov rax, SOB_TRUE_ADDRESS
    jmp .return

.wrong_type:
    mov rax, SOB_FALSE_ADDRESS
.return:
    leave
    ret

string_length:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    STRING_LENGTH rsi, rsi
    MAKE_INT(rax, rsi)

    leave
    ret

string_ref:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0) 
    STRING_ELEMENTS rsi, rsi
    mov rdi, PVAR(1)
    INT_VAL rdi, rdi
    shl rdi, 0
    add rsi, rdi

    mov sil, byte [rsi]
    MAKE_CHAR(rax, sil)

    leave
    ret

string_set:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0) 
    STRING_ELEMENTS rsi, rsi
    mov rdi, PVAR(1)
    INT_VAL rdi, rdi
    shl rdi, 0
    add rsi, rdi

    mov rax, PVAR(2)
    CHAR_VAL rax, rax
    mov byte [rsi], al
    mov rax, SOB_VOID_ADDRESS

    leave
    ret

make_string:
    push rbp
    mov rbp, rsp

    
    mov rsi, PVAR(0)
    INT_VAL rsi, rsi
    mov rdi, PVAR(1)
    CHAR_VAL rdi, rdi
    and rdi, 255

    MAKE_STRING rax, rsi, dil

    leave
    ret

symbol_to_string:
    push rbp
    mov rbp, rsp

    
    mov rsi, PVAR(0)
    SYMBOL_VAL rsi, rsi
    
    STRING_LENGTH rcx, rsi
    STRING_ELEMENTS rdi, rsi

    push rcx
    push rdi

    mov dil, byte [rdi]
    MAKE_CHAR(rax, dil)
    push rax
    MAKE_INT(rax, rcx)
    push rax
    push 2
    push SOB_NIL_ADDRESS
    call make_string
    add rsp, 4*8

    STRING_ELEMENTS rsi, rax

    pop rdi
    pop rcx

    cmp rcx, 0
    je .end
	
.loop:
    lea r8, [rdi+rcx]
    lea r9, [rsi+rcx]

    mov bl, byte [r8]
    mov byte [r9], bl
    
    loop .loop
.end:

    leave
    ret

char_to_integer:
    push rbp
    mov rbp, rsp

    
    mov rsi, PVAR(0)
    CHAR_VAL rsi, rsi
    and rsi, 255
    MAKE_INT(rax, rsi)

    leave
    ret

integer_to_char:
    push rbp
    mov rbp, rsp

    
    mov rsi, PVAR(0)
    INT_VAL rsi, rsi
    and rsi, 255
    MAKE_CHAR(rax, sil)

    leave
    ret

is_eq:
    push rbp
    mov rbp, rsp

    
    mov rsi, PVAR(0)
    mov rdi, PVAR(1)
    cmp rsi, rdi
    je .true
    mov rax, SOB_FALSE_ADDRESS
    jmp .return

.true:
    mov rax, SOB_TRUE_ADDRESS

.return:
    leave
    ret

bin_add:
    push rbp
    mov rbp, rsp

    mov r8, 0

    mov rsi, PVAR(0)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .test_next
    or r8, 1

.test_next:

    mov rsi, PVAR(1)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .load_numbers
    or r8, 2

.load_numbers:
    push r8

    shr r8, 1
    jc .first_arg_int
    mov rsi, PVAR(0)
    FLOAT_VAL rsi, rsi 
    movq xmm0, rsi
    jmp .load_next_float

.first_arg_int:
    mov rsi, PVAR(0)
    INT_VAL rsi, rsi
    cvtsi2sd xmm0, rsi

.load_next_float:
    shr r8, 1
    jc .second_arg_int
    mov rsi, PVAR(1)
    FLOAT_VAL rsi, rsi
    movq xmm1, rsi
    jmp .perform_float_op

.second_arg_int:
    mov rsi, PVAR(1)
    INT_VAL rsi, rsi
    cvtsi2sd xmm1, rsi

.perform_float_op:
    addsd xmm0, xmm1

    pop r8
    cmp r8, 3
    jne .return_float

    cvttsd2si rsi, xmm0
    MAKE_INT(rax, rsi)
    jmp .return

.return_float:
    movq rsi, xmm0
    MAKE_FLOAT(rax, rsi)

.return:

    leave
    ret

bin_mul:
    push rbp
    mov rbp, rsp

    mov r8, 0

    mov rsi, PVAR(0)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .test_next
    or r8, 1

.test_next:

    mov rsi, PVAR(1)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .load_numbers
    or r8, 2

.load_numbers:
    push r8

    shr r8, 1
    jc .first_arg_int
    mov rsi, PVAR(0)
    FLOAT_VAL rsi, rsi 
    movq xmm0, rsi
    jmp .load_next_float

.first_arg_int:
    mov rsi, PVAR(0)
    INT_VAL rsi, rsi
    cvtsi2sd xmm0, rsi

.load_next_float:
    shr r8, 1
    jc .second_arg_int
    mov rsi, PVAR(1)
    FLOAT_VAL rsi, rsi
    movq xmm1, rsi
    jmp .perform_float_op

.second_arg_int:
    mov rsi, PVAR(1)
    INT_VAL rsi, rsi
    cvtsi2sd xmm1, rsi

.perform_float_op:
    mulsd xmm0, xmm1

    pop r8
    cmp r8, 3
    jne .return_float

    cvttsd2si rsi, xmm0
    MAKE_INT(rax, rsi)
    jmp .return

.return_float:
    movq rsi, xmm0
    MAKE_FLOAT(rax, rsi)

.return:

    leave
    ret

bin_sub:
    push rbp
    mov rbp, rsp

    mov r8, 0

    mov rsi, PVAR(0)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .test_next
    or r8, 1

.test_next:

    mov rsi, PVAR(1)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .load_numbers
    or r8, 2

.load_numbers:
    push r8

    shr r8, 1
    jc .first_arg_int
    mov rsi, PVAR(0)
    FLOAT_VAL rsi, rsi 
    movq xmm0, rsi
    jmp .load_next_float

.first_arg_int:
    mov rsi, PVAR(0)
    INT_VAL rsi, rsi
    cvtsi2sd xmm0, rsi

.load_next_float:
    shr r8, 1
    jc .second_arg_int
    mov rsi, PVAR(1)
    FLOAT_VAL rsi, rsi
    movq xmm1, rsi
    jmp .perform_float_op

.second_arg_int:
    mov rsi, PVAR(1)
    INT_VAL rsi, rsi
    cvtsi2sd xmm1, rsi

.perform_float_op:
    subsd xmm0, xmm1

    pop r8
    cmp r8, 3
    jne .return_float

    cvttsd2si rsi, xmm0
    MAKE_INT(rax, rsi)
    jmp .return

.return_float:
    movq rsi, xmm0
    MAKE_FLOAT(rax, rsi)

.return:

    leave
    ret

bin_div:
    push rbp
    mov rbp, rsp

    mov r8, 0

    mov rsi, PVAR(0)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .test_next
    or r8, 1

.test_next:

    mov rsi, PVAR(1)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .load_numbers
    or r8, 2

.load_numbers:
    push r8

    shr r8, 1
    jc .first_arg_int
    mov rsi, PVAR(0)
    FLOAT_VAL rsi, rsi 
    movq xmm0, rsi
    jmp .load_next_float

.first_arg_int:
    mov rsi, PVAR(0)
    INT_VAL rsi, rsi
    cvtsi2sd xmm0, rsi

.load_next_float:
    shr r8, 1
    jc .second_arg_int
    mov rsi, PVAR(1)
    FLOAT_VAL rsi, rsi
    movq xmm1, rsi
    jmp .perform_float_op

.second_arg_int:
    mov rsi, PVAR(1)
    INT_VAL rsi, rsi
    cvtsi2sd xmm1, rsi

.perform_float_op:
    divsd xmm0, xmm1

    pop r8
    cmp r8, 3
    jne .return_float

    cvttsd2si rsi, xmm0
    MAKE_INT(rax, rsi)
    jmp .return

.return_float:
    movq rsi, xmm0
    MAKE_FLOAT(rax, rsi)

.return:

    leave
    ret

bin_lt:
    push rbp
    mov rbp, rsp

    mov r8, 0

    mov rsi, PVAR(0)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .test_next
    or r8, 1

.test_next:

    mov rsi, PVAR(1)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .load_numbers
    or r8, 2

.load_numbers:
    push r8

    shr r8, 1
    jc .first_arg_int
    mov rsi, PVAR(0)
    FLOAT_VAL rsi, rsi 
    movq xmm0, rsi
    jmp .load_next_float

.first_arg_int:
    mov rsi, PVAR(0)
    INT_VAL rsi, rsi
    cvtsi2sd xmm0, rsi

.load_next_float:
    shr r8, 1
    jc .second_arg_int
    mov rsi, PVAR(1)
    FLOAT_VAL rsi, rsi
    movq xmm1, rsi
    jmp .perform_float_op

.second_arg_int:
    mov rsi, PVAR(1)
    INT_VAL rsi, rsi
    cvtsi2sd xmm1, rsi

.perform_float_op:
    cmpltsd xmm0, xmm1

    pop r8
    cmp r8, 3
    jne .return_float

    cvttsd2si rsi, xmm0
    MAKE_INT(rax, rsi)
    jmp .return

.return_float:
    movq rsi, xmm0
    MAKE_FLOAT(rax, rsi)

.return:

    INT_VAL rsi, rax
    cmp rsi, 0
    je .return_false
    mov rax, SOB_TRUE_ADDRESS
    jmp .final_return

.return_false:
    mov rax, SOB_FALSE_ADDRESS

.final_return:


    leave
    ret

bin_equ:
    push rbp
    mov rbp, rsp

    mov r8, 0

    mov rsi, PVAR(0)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .test_next
    or r8, 1

.test_next:

    mov rsi, PVAR(1)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .load_numbers
    or r8, 2

.load_numbers:
    push r8

    shr r8, 1
    jc .first_arg_int
    mov rsi, PVAR(0)
    FLOAT_VAL rsi, rsi 
    movq xmm0, rsi
    jmp .load_next_float

.first_arg_int:
    mov rsi, PVAR(0)
    INT_VAL rsi, rsi
    cvtsi2sd xmm0, rsi

.load_next_float:
    shr r8, 1
    jc .second_arg_int
    mov rsi, PVAR(1)
    FLOAT_VAL rsi, rsi
    movq xmm1, rsi
    jmp .perform_float_op

.second_arg_int:
    mov rsi, PVAR(1)
    INT_VAL rsi, rsi
    cvtsi2sd xmm1, rsi

.perform_float_op:
    cmpeqsd xmm0, xmm1

    pop r8
    cmp r8, 3
    jne .return_float

    cvttsd2si rsi, xmm0
    MAKE_INT(rax, rsi)
    jmp .return

.return_float:
    movq rsi, xmm0
    MAKE_FLOAT(rax, rsi)

.return:

    INT_VAL rsi, rax
    cmp rsi, 0
    je .return_false
    mov rax, SOB_TRUE_ADDRESS
    jmp .final_return

.return_false:
    mov rax, SOB_FALSE_ADDRESS

.final_return:


    leave
    ret


