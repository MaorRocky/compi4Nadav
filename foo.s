
;;; All the macros and the scheme-object printing procedure
;;; are defined in compiler.s
%include "compiler.s"

section .bss
;;; This pointer is used to manage allocations on our heap.
malloc_pointer:
    resq 1

section .data
const_tbl:
MAKE_VOID
MAKE_NIL
MAKE_BOOL(0)
MAKE_BOOL(1)
MAKE_LITERAL_STRING "whatever",8
MAKE_LITERAL_SYMBOL(const_tbl+6)
MAKE_LITERAL_INT(1)
MAKE_LITERAL_INT(0)
MAKE_LITERAL_CHAR(0)
MAKE_LITERAL_INT(2)
MAKE_LITERAL_INT(3)
MAKE_LITERAL_INT(4)
MAKE_LITERAL_INT(5)
MAKE_LITERAL_INT(6)
MAKE_LITERAL_PAIR(const_tbl+88, const_tbl+1)
MAKE_LITERAL_PAIR(const_tbl+79, const_tbl+97)
MAKE_LITERAL_PAIR(const_tbl+70, const_tbl+114)

;;; These macro definitions are required for the primitive
;;; definitions in the epilogue to work properly
%define SOB_VOID_ADDRESS const_tbl+0
%define SOB_NIL_ADDRESS const_tbl+1
%define SOB_FALSE_ADDRESS const_tbl+2
%define SOB_TRUE_ADDRESS const_tbl+4

fvar_tbl:
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED

global main
section .text
main:
    push rbp

    ;; set up the heap
    mov rdi, GB(4)
    call malloc
    mov [malloc_pointer], rax

    ;; Set up the dummy activation frame
    ;; The dummy return address is T_UNDEFINED
    ;; (which a is a macro for 0) so that returning
    ;; from the top level (which SHOULD NOT HAPPEN
    ;; AND IS A BUG) will cause a segfault.
    push 0
    push qword SOB_NIL_ADDRESS
    push qword T_UNDEFINED
    push rsp
    mov rbp,rsp

    ;; Set up the primitive stdlib fvars:
    ;; Since the primtive procedures are defined in assembly,
    ;; they are not generated by scheme (define ...) expressions.
    ;; This is where we emulate the missing (define ...) expressions
;; for all the primitive procedures.(map list '((a b c) (1 2 3)))
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_boolean)
    mov [fvar_tbl+8*0], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_float)
    mov [fvar_tbl+8*1], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_integer)
    mov [fvar_tbl+8*2], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_pair)
    mov [fvar_tbl+8*3], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_null)
    mov [fvar_tbl+8*4], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_char)
    mov [fvar_tbl+8*5], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_string)
    mov [fvar_tbl+8*6], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_procedure)
    mov [fvar_tbl+8*7], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_symbol)
    mov [fvar_tbl+8*8], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, string_length)
    mov [fvar_tbl+8*9], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, string_ref)
    mov [fvar_tbl+8*10], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, string_set)
    mov [fvar_tbl+8*11], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, make_string)
    mov [fvar_tbl+8*12], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, symbol_to_string)
    mov [fvar_tbl+8*13], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, char_to_integer)
    mov [fvar_tbl+8*14], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, integer_to_char)
    mov [fvar_tbl+8*15], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_eq)
    mov [fvar_tbl+8*16], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, bin_add)
    mov [fvar_tbl+8*17], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, bin_mul)
    mov [fvar_tbl+8*18], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, bin_sub)
    mov [fvar_tbl+8*19], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, bin_div)
    mov [fvar_tbl+8*20], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, bin_lt)
    mov [fvar_tbl+8*21], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, bin_equ)
    mov [fvar_tbl+8*22], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, car)
    mov [fvar_tbl+8*23], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, cdr)
    mov [fvar_tbl+8*24], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, cons_make)
    mov [fvar_tbl+8*25], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, set_car)
    mov [fvar_tbl+8*26], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, set_cdr)
    mov [fvar_tbl+8*27], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, apply)
    mov [fvar_tbl+8*28], rax

user_code_fragment:

;;; The code you compiled will be catenated here.
;;; It will be executed immediately after the closures for 
;;; the primitive procedures are set up.


push SOB_NIL_ADDRESS

mov rax, qword [fvar_tbl + 8*28]

push rax

mov rax, qword [fvar_tbl + 8*25]

push rax

mov rax, qword [fvar_tbl + 8*24]

push rax

mov rax, qword [fvar_tbl + 8*23]

push rax

mov rax, qword [fvar_tbl + 8*4]

push rax

push 5
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode_14785251)
jmp Lcont_14785251
Lcode_14785251:
push rbp
mov rbp, rsp

push SOB_NIL_ADDRESS

mov rax, const_tbl+23

push rax

push 1

mov rsi, [rbp + 8 * 3]			;; (*rsi holds the number of parametres on the stack*)
inc rsi
lea rsi, [rsi * 8]
MALLOC rdx, rsi			;; (*now rdx points to the allocated memory for the new vector*)
mov rcx, [rbp + 8 * 3]
mov rdi, 0			;;(*rdi will be used to point to the next address in the vector*)

mov r9, 4
;; (*start of loop to copy parameters to the new allocated vector*)
copy_params_loop_858766356:
cmp rdi, rcx
je after_params_copy_858766356
mov rsi, [rbp + 8 * r9]			;;(*now rsi points to the next parameter on the stack*)
mov [rdx + 8*rdi], rsi			;;(*copying the parameter to the new allocated vector*)
inc rdi
inc r9
jmp copy_params_loop_858766356
;; (*now rdx points to the new vector to be added to ext_env*)
;; (*mov 0 to all neccessary registers*)
after_params_copy_858766356:
mov qword [rdx + 8*rdi], SOB_NIL_ADDRESS
mov rcx, 0
mov rdi, 0
mov rsi, 0
;; (*now we need to create ext_env by copying env and adding the new vector*)
MALLOC rbx, 16			;;(*rbx points to a new allocated space for ext_env*)
mov [rbx], rdx			;;(*coping the new vector to ext_env[0]*)
mov rsi, [rbp + 8 * 2]			;;(*rsi points to current env*)
mov rcx, 1			;;(*rcx is the loop counter*)
mov r9, 0			;;(*r9 will be used to point to the next vector in current env to be copied*)
mov rdi, 1			;;(*rdi will be used to point to the next address in ext_env*)
mov r8, 0
;; (*start of loop for copying env[i] to ext_env[i+1]*)
copy_env_loop_858766356:
cmp r9, rcx
je after_env_copy_858766356
mov r8, [rsi + 8 * r9]			;;(*r8 points to the next vector int current env to be copied*) 
mov [rbx + 8 * rdi], r8			;;(*copying the pointer to the vector from env to ext_env*)
inc r9
inc rdi
jmp copy_env_loop_858766356
after_env_copy_858766356:

MAKE_CLOSURE(rax, rbx, Lcode_858766356)
jmp Lcont_858766356
Lcode_858766356:
push rbp
mov rbp, rsp

mov qword rax, [rbp + 32]
MALLOC r11, 8
mov qword [r11], rax
mov rax, r11

mov qword [rbp + 32], rax
mov rax, SOB_VOID_ADDRESS




mov rsi, [rbp + 8 * 3]			;; (*rsi holds the number of parametres on the stack*)
inc rsi
lea rsi, [rsi * 8]
MALLOC rdx, rsi			;; (*now rdx points to the allocated memory for the new vector*)
mov rcx, [rbp + 8 * 3]
mov rdi, 0			;;(*rdi will be used to point to the next address in the vector*)

mov r9, 4
;; (*start of loop to copy parameters to the new allocated vector*)
copy_params_loop_139310441:
cmp rdi, rcx
je after_params_copy_139310441
mov rsi, [rbp + 8 * r9]			;;(*now rsi points to the next parameter on the stack*)
mov [rdx + 8*rdi], rsi			;;(*copying the parameter to the new allocated vector*)
inc rdi
inc r9
jmp copy_params_loop_139310441
;; (*now rdx points to the new vector to be added to ext_env*)
;; (*mov 0 to all neccessary registers*)
after_params_copy_139310441:
mov qword [rdx + 8*rdi], SOB_NIL_ADDRESS
mov rcx, 0
mov rdi, 0
mov rsi, 0
;; (*now we need to create ext_env by copying env and adding the new vector*)
MALLOC rbx, 24			;;(*rbx points to a new allocated space for ext_env*)
mov [rbx], rdx			;;(*copying the new vector to ext_env[0]*)
mov rsi, [rbp + 8 * 2]			;;(*rsi points to current env*)
mov rcx, 2			;;(*rcx is the loop counter*)
mov r9, 0			;;(*r9 will be used to point to the next vector in current env to be copied*)
mov rdi, 1			;;(*rdi will be used to point to the next address in ext_env*)
mov r8, 0
;; (*start of loop for copying env[i] to ext_env[i+1]*)
copy_env_loop_139310441:
cmp r9, rcx
je after_env_copy_139310441
mov r8, [rsi + 8 * r9]			;;(*r8 points to the next vector int current env to be copied*) 
mov [rbx + 8 * rdi], r8			;;(*copying the pointer to the vector from env to ext_env*)
inc r9
inc rdi
jmp copy_env_loop_139310441
after_env_copy_139310441:

MAKE_CLOSURE(rax, rbx, Lcode_139310441)
jmp Lcont_139310441
Lcode_139310441:
push rbp
mov rbp, rsp
mov rdi, 2
mov rsi, qword [rbp + 8*3]
cmp qword rdi, rsi
jb vector_size_is_total_num_of_params_139310441
mov rsi, 0
mov rsi, 2
jmp create_vector_139310441
vector_size_is_total_num_of_params_139310441:
mov rsi, [rbp + 8*3]
create_vector_139310441:
lea rsi, [rsi*8]
mov r9, 0
mov rbx, 0
mov rdx, 0
MALLOC r9, rsi
mov rsi, 0
mov rsi, 2
mov rcx, 0
copy_non_opt_params_list_for_opt_139310441:
cmp rcx, rsi
je end_copy_non_opt_params_list_for_opt_139310441
mov rbx, qword PVAR(rcx)
mov qword [r9 + 8 * rcx], rbx
inc rcx
jmp copy_non_opt_params_list_for_opt_139310441
end_copy_non_opt_params_list_for_opt_139310441:
mov rsi, [rbp + 8*3]
cmp rsi, 2
je enlarge_stack_139310441
shrink_stack_139310441:
mov rdi, 2
dec rsi
mov r12, 0
mov r11, 0
mov r10, 0
mov r11, PVAR(rsi)
dec rsi
MAKE_PAIR(r12, r11, SOB_NIL_ADDRESS)
dec rdi
create_opt_params_list_139310441:
cmp rdi, rsi
je pop_and_adjust_stack_shrink_stack_139310441
mov r11, qword PVAR(rsi)
mov r10, r12
MAKE_PAIR(r12, r11, r10)
dec rsi
jmp create_opt_params_list_139310441
pop_and_adjust_stack_shrink_stack_139310441:
mov rsi, 0
mov rdi, 0
mov rcx,0
mov rbx, 0
mov rdi, [rbp + 8]
mov rcx, [rbp + 8*2]
mov rsi, [rbp + 8*3]
add rsp, 32
mov rbx, 0
lea rbx, [rsi*8]
add rsp, rbx
push qword r12
mov r12, 0
mov r12, 2
dec r12
mov rbx, 0
shrink_push_non_optional_params_loop_139310441:
cmp rbx, r12
jbe end_shrink_push_non_optional_params_loop_139310441
push qword [r9 + 8*r12]
dec r12
jmp shrink_push_non_optional_params_loop_139310441
end_shrink_push_non_optional_params_loop_139310441:
mov r15, 0
dec r15
cmp r15, r12
je dont_push_139310441
push qword [r9 + 8*r12]
dont_push_139310441:
mov rsi, 0
mov rsi, 2
inc rsi
push rsi
push rcx
push rdi
jmp body_of_opt_139310441
enlarge_stack_139310441:
mov rsi, 0
mov rdi, 0
mov rcx,0
mov rbx, 0
mov rdx, 0
mov rdx, qword [rbp + 8*3]
mov rdi, [rbp + 8]
mov rcx, [rbp + 8*2]
mov rsi, [rbp + 8*3]
add rsp, 32
lea rbx, [rsi*8]
add rsp, rbx
push SOB_NIL_ADDRESS
mov r10, 0
mov r11, 0
mov r10, rsi
dec r10
mov rbx, 0
enlarge_push_non_optional_params_loop_139310441:
cmp rbx, r10
jb end_enlarge_push_non_optional_params_loop_139310441
push qword [r9 + 8*r10]
dec r10
jmp enlarge_push_non_optional_params_loop_139310441
end_enlarge_push_non_optional_params_loop_139310441:
mov rsi, rdx
inc rsi
push rsi
push rcx
push rdi
body_of_opt_139310441:
push rbp
mov rbp, rsp

push SOB_NIL_ADDRESS

mov qword rax, [rbp + 40]

push rax

push 1
mov rax, qword [rbp + 16]
mov rax, qword [rax + 8]
mov rax, qword [rax + 0]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_977879997:

cmp rax, SOB_FALSE_ADDRESS
je Lelse_743829425
mov rax, const_tbl+1

jmp Lexit_530108890
Lelse_743829425:

push SOB_NIL_ADDRESS

mov qword rax, [rbp + 48]

push rax

push 1
mov rax, qword [rbp + 16]
mov rax, qword [rax + 8]
mov rax, qword [rax + 0]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_575223720:

cmp rax, SOB_FALSE_ADDRESS
je Lelse_479628152

push SOB_NIL_ADDRESS


push SOB_NIL_ADDRESS


push SOB_NIL_ADDRESS

mov qword rax, [rbp + 40]

push rax

push 1
mov rax, qword [rbp + 16]
mov rax, qword [rax + 8]
mov rax, qword [rax + 16]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_942578091:

push rax

mov qword rax, [rbp + 32]

push rax

push 2
mov rax, qword [rbp + 16]
mov rax, qword [rax + 0]
mov rax, qword [rax + 0]

mov rax, qword [rax]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_599609540:

push rax


push SOB_NIL_ADDRESS


push SOB_NIL_ADDRESS

mov qword rax, [rbp + 40]

push rax

push 1
mov rax, qword [rbp + 16]
mov rax, qword [rax + 8]
mov rax, qword [rax + 8]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_435807891:

push rax

push 1
mov qword rax, [rbp + 32]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_463926866:

push rax

push 2
mov rax, qword [rbp + 16]
mov rax, qword [rax + 8]
mov rax, qword [rax + 24]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_663533580:

jmp Lexit_744807207
Lelse_479628152:

push SOB_NIL_ADDRESS


push SOB_NIL_ADDRESS


push SOB_NIL_ADDRESS

mov qword rax, [rbp + 48]

push rax

mov rax, qword [rbp + 16]
mov rax, qword [rax + 8]
mov rax, qword [rax + 16]

push rax

push 2
mov rax, qword [rbp + 16]
mov rax, qword [rax + 0]
mov rax, qword [rax + 0]

mov rax, qword [rax]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_304507802:

push rax


push SOB_NIL_ADDRESS

mov qword rax, [rbp + 40]

push rax

push 1
mov rax, qword [rbp + 16]
mov rax, qword [rax + 8]
mov rax, qword [rax + 16]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_198288938:

push rax

mov qword rax, [rbp + 32]

push rax

mov rax, qword [fvar_tbl + 8*29]

push rax

push 4
mov rax, qword [rbp + 16]
mov rax, qword [rax + 8]
mov rax, qword [rax + 32]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_308140838:

push rax


push SOB_NIL_ADDRESS


push SOB_NIL_ADDRESS

mov qword rax, [rbp + 48]

push rax

mov rax, qword [rbp + 16]
mov rax, qword [rax + 8]
mov rax, qword [rax + 8]

push rax

push 2
mov rax, qword [rbp + 16]
mov rax, qword [rax + 0]
mov rax, qword [rax + 0]

mov rax, qword [rax]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_510529514:

push rax


push SOB_NIL_ADDRESS

mov qword rax, [rbp + 40]

push rax

push 1
mov rax, qword [rbp + 16]
mov rax, qword [rax + 8]
mov rax, qword [rax + 8]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_15076718:

push rax

mov qword rax, [rbp + 32]

push rax

push 3
mov rax, qword [rbp + 16]
mov rax, qword [rax + 8]
mov rax, qword [rax + 32]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_483666380:

push rax

push 2
mov rax, qword [rbp + 16]
mov rax, qword [rax + 8]
mov rax, qword [rax + 24]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_847232054:

Lexit_744807207:

Lexit_530108890:

leave
ret
Lcont_139310441:


push rax
mov qword rax, [rbp + 32]

pop qword [rax]
mov rax, SOB_VOID_ADDRESS


mov qword rax, [rbp + 32]

mov rax, qword [rax]



leave
ret
Lcont_858766356:


push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_713567136:

leave
ret
Lcont_14785251:


push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_621731022:

mov [fvar_tbl + 8*29], rax
mov rax, SOB_VOID_ADDRESS
	call write_sob_if_not_void

MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode_283791396)
jmp Lcont_283791396
Lcode_283791396:
push rbp
mov rbp, rsp

push SOB_NIL_ADDRESS


push SOB_NIL_ADDRESS


push SOB_NIL_ADDRESS

mov qword rax, [rbp + 48]

push rax

push 1
mov rax, qword [fvar_tbl + 8*23]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_269997124:

push rax

mov qword rax, [rbp + 40]

push rax

push 2
mov qword rax, [rbp + 32]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_541080542:

push rax

push 1

mov rsi, [rbp + 8 * 3]			;; (*rsi holds the number of parametres on the stack*)
inc rsi
lea rsi, [rsi * 8]
MALLOC rdx, rsi			;; (*now rdx points to the allocated memory for the new vector*)
mov rcx, [rbp + 8 * 3]
mov rdi, 0			;;(*rdi will be used to point to the next address in the vector*)

mov r9, 4
;; (*start of loop to copy parameters to the new allocated vector*)
copy_params_loop_407118687:
cmp rdi, rcx
je after_params_copy_407118687
mov rsi, [rbp + 8 * r9]			;;(*now rsi points to the next parameter on the stack*)
mov [rdx + 8*rdi], rsi			;;(*copying the parameter to the new allocated vector*)
inc rdi
inc r9
jmp copy_params_loop_407118687
;; (*now rdx points to the new vector to be added to ext_env*)
;; (*mov 0 to all neccessary registers*)
after_params_copy_407118687:
mov qword [rdx + 8*rdi], SOB_NIL_ADDRESS
mov rcx, 0
mov rdi, 0
mov rsi, 0
;; (*now we need to create ext_env by copying env and adding the new vector*)
MALLOC rbx, 16			;;(*rbx points to a new allocated space for ext_env*)
mov [rbx], rdx			;;(*coping the new vector to ext_env[0]*)
mov rsi, [rbp + 8 * 2]			;;(*rsi points to current env*)
mov rcx, 1			;;(*rcx is the loop counter*)
mov r9, 0			;;(*r9 will be used to point to the next vector in current env to be copied*)
mov rdi, 1			;;(*rdi will be used to point to the next address in ext_env*)
mov r8, 0
;; (*start of loop for copying env[i] to ext_env[i+1]*)
copy_env_loop_407118687:
cmp r9, rcx
je after_env_copy_407118687
mov r8, [rsi + 8 * r9]			;;(*r8 points to the next vector int current env to be copied*) 
mov [rbx + 8 * rdi], r8			;;(*copying the pointer to the vector from env to ext_env*)
inc r9
inc rdi
jmp copy_env_loop_407118687
after_env_copy_407118687:

MAKE_CLOSURE(rax, rbx, Lcode_407118687)
jmp Lcont_407118687
Lcode_407118687:
push rbp
mov rbp, rsp

push SOB_NIL_ADDRESS

mov rax, const_tbl+1

push rax


push SOB_NIL_ADDRESS

mov rax, qword [rbp + 16]
mov rax, qword [rax + 0]
mov rax, qword [rax + 16]

push rax

push 1
mov rax, qword [fvar_tbl + 8*24]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_634982515:

push rax

push 2
mov rax, qword [fvar_tbl + 8*16]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_367008404:

cmp rax, SOB_FALSE_ADDRESS
je Lelse_868569136
mov qword rax, [rbp + 32]

jmp Lexit_793128188
Lelse_868569136:

push SOB_NIL_ADDRESS


push SOB_NIL_ADDRESS

mov rax, qword [rbp + 16]
mov rax, qword [rax + 0]
mov rax, qword [rax + 16]

push rax

push 1
mov rax, qword [fvar_tbl + 8*24]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_771724904:

push rax

mov qword rax, [rbp + 32]

push rax

mov rax, qword [rbp + 16]
mov rax, qword [rax + 0]
mov rax, qword [rax + 0]

push rax

push 3
mov rax, qword [fvar_tbl + 8*30]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_844370963:

Lexit_793128188:

leave
ret
Lcont_407118687:


push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_380528153:

leave
ret
Lcont_283791396:


mov [fvar_tbl + 8*30], rax
mov rax, SOB_VOID_ADDRESS
	call write_sob_if_not_void

MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode_661312616)
jmp Lcont_661312616
Lcode_661312616:
push rbp
mov rbp, rsp

push SOB_NIL_ADDRESS

mov rax, const_tbl+23

push rax

mov rax, const_tbl+23

push rax

push 2

mov rsi, [rbp + 8 * 3]			;; (*rsi holds the number of parametres on the stack*)
inc rsi
lea rsi, [rsi * 8]
MALLOC rdx, rsi			;; (*now rdx points to the allocated memory for the new vector*)
mov rcx, [rbp + 8 * 3]
mov rdi, 0			;;(*rdi will be used to point to the next address in the vector*)

mov r9, 4
;; (*start of loop to copy parameters to the new allocated vector*)
copy_params_loop_525340320:
cmp rdi, rcx
je after_params_copy_525340320
mov rsi, [rbp + 8 * r9]			;;(*now rsi points to the next parameter on the stack*)
mov [rdx + 8*rdi], rsi			;;(*copying the parameter to the new allocated vector*)
inc rdi
inc r9
jmp copy_params_loop_525340320
;; (*now rdx points to the new vector to be added to ext_env*)
;; (*mov 0 to all neccessary registers*)
after_params_copy_525340320:
mov qword [rdx + 8*rdi], SOB_NIL_ADDRESS
mov rcx, 0
mov rdi, 0
mov rsi, 0
;; (*now we need to create ext_env by copying env and adding the new vector*)
MALLOC rbx, 16			;;(*rbx points to a new allocated space for ext_env*)
mov [rbx], rdx			;;(*coping the new vector to ext_env[0]*)
mov rsi, [rbp + 8 * 2]			;;(*rsi points to current env*)
mov rcx, 1			;;(*rcx is the loop counter*)
mov r9, 0			;;(*r9 will be used to point to the next vector in current env to be copied*)
mov rdi, 1			;;(*rdi will be used to point to the next address in ext_env*)
mov r8, 0
;; (*start of loop for copying env[i] to ext_env[i+1]*)
copy_env_loop_525340320:
cmp r9, rcx
je after_env_copy_525340320
mov r8, [rsi + 8 * r9]			;;(*r8 points to the next vector int current env to be copied*) 
mov [rbx + 8 * rdi], r8			;;(*copying the pointer to the vector from env to ext_env*)
inc r9
inc rdi
jmp copy_env_loop_525340320
after_env_copy_525340320:

MAKE_CLOSURE(rax, rbx, Lcode_525340320)
jmp Lcont_525340320
Lcode_525340320:
push rbp
mov rbp, rsp

mov qword rax, [rbp + 40]
MALLOC r11, 8
mov qword [r11], rax
mov rax, r11

mov qword [rbp + 40], rax
mov rax, SOB_VOID_ADDRESS




push SOB_NIL_ADDRESS

mov rax, qword [rbp + 16]
mov rax, qword [rax + 0]
mov rax, qword [rax + 16]

push rax

push 1
mov rax, qword [fvar_tbl + 8*32]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_882359236:

mov qword [rbp + 32], rax
mov rax, SOB_VOID_ADDRESS



mov rsi, [rbp + 8 * 3]			;; (*rsi holds the number of parametres on the stack*)
inc rsi
lea rsi, [rsi * 8]
MALLOC rdx, rsi			;; (*now rdx points to the allocated memory for the new vector*)
mov rcx, [rbp + 8 * 3]
mov rdi, 0			;;(*rdi will be used to point to the next address in the vector*)

mov r9, 4
;; (*start of loop to copy parameters to the new allocated vector*)
copy_params_loop_644830334:
cmp rdi, rcx
je after_params_copy_644830334
mov rsi, [rbp + 8 * r9]			;;(*now rsi points to the next parameter on the stack*)
mov [rdx + 8*rdi], rsi			;;(*copying the parameter to the new allocated vector*)
inc rdi
inc r9
jmp copy_params_loop_644830334
;; (*now rdx points to the new vector to be added to ext_env*)
;; (*mov 0 to all neccessary registers*)
after_params_copy_644830334:
mov qword [rdx + 8*rdi], SOB_NIL_ADDRESS
mov rcx, 0
mov rdi, 0
mov rsi, 0
;; (*now we need to create ext_env by copying env and adding the new vector*)
MALLOC rbx, 24			;;(*rbx points to a new allocated space for ext_env*)
mov [rbx], rdx			;;(*coping the new vector to ext_env[0]*)
mov rsi, [rbp + 8 * 2]			;;(*rsi points to current env*)
mov rcx, 2			;;(*rcx is the loop counter*)
mov r9, 0			;;(*r9 will be used to point to the next vector in current env to be copied*)
mov rdi, 1			;;(*rdi will be used to point to the next address in ext_env*)
mov r8, 0
;; (*start of loop for copying env[i] to ext_env[i+1]*)
copy_env_loop_644830334:
cmp r9, rcx
je after_env_copy_644830334
mov r8, [rsi + 8 * r9]			;;(*r8 points to the next vector int current env to be copied*) 
mov [rbx + 8 * rdi], r8			;;(*copying the pointer to the vector from env to ext_env*)
inc r9
inc rdi
jmp copy_env_loop_644830334
after_env_copy_644830334:

MAKE_CLOSURE(rax, rbx, Lcode_644830334)
jmp Lcont_644830334
Lcode_644830334:
push rbp
mov rbp, rsp

push SOB_NIL_ADDRESS


push SOB_NIL_ADDRESS

mov qword rax, [rbp + 40]

push rax


push SOB_NIL_ADDRESS

mov qword rax, [rbp + 48]

push rax

push 1
mov rax, qword [fvar_tbl + 8*23]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_157380188:

push rax

push 2
mov qword rax, [rbp + 32]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_222584391:

push rax

push 1

mov rsi, [rbp + 8 * 3]			;; (*rsi holds the number of parametres on the stack*)
inc rsi
lea rsi, [rsi * 8]
MALLOC rdx, rsi			;; (*now rdx points to the allocated memory for the new vector*)
mov rcx, [rbp + 8 * 3]
mov rdi, 0			;;(*rdi will be used to point to the next address in the vector*)

mov r9, 4
;; (*start of loop to copy parameters to the new allocated vector*)
copy_params_loop_904360012:
cmp rdi, rcx
je after_params_copy_904360012
mov rsi, [rbp + 8 * r9]			;;(*now rsi points to the next parameter on the stack*)
mov [rdx + 8*rdi], rsi			;;(*copying the parameter to the new allocated vector*)
inc rdi
inc r9
jmp copy_params_loop_904360012
;; (*now rdx points to the new vector to be added to ext_env*)
;; (*mov 0 to all neccessary registers*)
after_params_copy_904360012:
mov qword [rdx + 8*rdi], SOB_NIL_ADDRESS
mov rcx, 0
mov rdi, 0
mov rsi, 0
;; (*now we need to create ext_env by copying env and adding the new vector*)
MALLOC rbx, 32			;;(*rbx points to a new allocated space for ext_env*)
mov [rbx], rdx			;;(*coping the new vector to ext_env[0]*)
mov rsi, [rbp + 8 * 2]			;;(*rsi points to current env*)
mov rcx, 3			;;(*rcx is the loop counter*)
mov r9, 0			;;(*r9 will be used to point to the next vector in current env to be copied*)
mov rdi, 1			;;(*rdi will be used to point to the next address in ext_env*)
mov r8, 0
;; (*start of loop for copying env[i] to ext_env[i+1]*)
copy_env_loop_904360012:
cmp r9, rcx
je after_env_copy_904360012
mov r8, [rsi + 8 * r9]			;;(*r8 points to the next vector int current env to be copied*) 
mov [rbx + 8 * rdi], r8			;;(*copying the pointer to the vector from env to ext_env*)
inc r9
inc rdi
jmp copy_env_loop_904360012
after_env_copy_904360012:

MAKE_CLOSURE(rax, rbx, Lcode_904360012)
jmp Lcont_904360012
Lcode_904360012:
push rbp
mov rbp, rsp

push SOB_NIL_ADDRESS

mov rax, const_tbl+1

push rax


push SOB_NIL_ADDRESS

mov rax, qword [rbp + 16]
mov rax, qword [rax + 0]
mov rax, qword [rax + 16]

push rax

push 1
mov rax, qword [fvar_tbl + 8*24]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_259038460:

push rax

push 2
mov rax, qword [fvar_tbl + 8*16]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_67564655:

cmp rax, SOB_FALSE_ADDRESS
je Lelse_583061130
mov qword rax, [rbp + 32]

jmp Lexit_355434846
Lelse_583061130:

push SOB_NIL_ADDRESS


push SOB_NIL_ADDRESS

mov rax, qword [rbp + 16]
mov rax, qword [rax + 0]
mov rax, qword [rax + 16]

push rax

push 1
mov rax, qword [fvar_tbl + 8*24]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_675348438:

push rax

mov qword rax, [rbp + 32]

push rax

mov rax, qword [rbp + 16]
mov rax, qword [rax + 0]
mov rax, qword [rax + 0]

push rax

push 3
mov rax, qword [rbp + 16]
mov rax, qword [rax + 8]
mov rax, qword [rax + 8]

mov rax, qword [rax]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_551702454:

Lexit_355434846:

leave
ret
Lcont_904360012:


push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_911393886:

leave
ret
Lcont_644830334:


push rax
mov qword rax, [rbp + 40]

pop qword [rax]
mov rax, SOB_VOID_ADDRESS



push SOB_NIL_ADDRESS

mov qword rax, [rbp + 32]

push rax

mov rax, qword [rbp + 16]
mov rax, qword [rax + 0]
mov rax, qword [rax + 8]

push rax

mov rax, qword [rbp + 16]
mov rax, qword [rax + 0]
mov rax, qword [rax + 0]

push rax

push 3
mov qword rax, [rbp + 40]

mov rax, qword [rax]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_837406327:



leave
ret
Lcont_525340320:


push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_231413264:

leave
ret
Lcont_661312616:


mov [fvar_tbl + 8*31], rax
mov rax, SOB_VOID_ADDRESS
	call write_sob_if_not_void

MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode_905522432)
jmp Lcont_905522432
Lcode_905522432:
push rbp
mov rbp, rsp
mov rdi, 0
mov rsi, qword [rbp + 8*3]
cmp qword rdi, rsi
jb vector_size_is_total_num_of_params_905522432
mov rsi, 0
mov rsi, 0
jmp create_vector_905522432
vector_size_is_total_num_of_params_905522432:
mov rsi, [rbp + 8*3]
create_vector_905522432:
lea rsi, [rsi*8]
mov r9, 0
mov rbx, 0
mov rdx, 0
MALLOC r9, rsi
mov rsi, 0
mov rsi, 0
mov rcx, 0
copy_non_opt_params_list_for_opt_905522432:
cmp rcx, rsi
je end_copy_non_opt_params_list_for_opt_905522432
mov rbx, qword PVAR(rcx)
mov qword [r9 + 8 * rcx], rbx
inc rcx
jmp copy_non_opt_params_list_for_opt_905522432
end_copy_non_opt_params_list_for_opt_905522432:
mov rsi, [rbp + 8*3]
cmp rsi, 0
je enlarge_stack_905522432
shrink_stack_905522432:
mov rdi, 0
dec rsi
mov r12, 0
mov r11, 0
mov r10, 0
mov r11, PVAR(rsi)
dec rsi
MAKE_PAIR(r12, r11, SOB_NIL_ADDRESS)
dec rdi
create_opt_params_list_905522432:
cmp rdi, rsi
je pop_and_adjust_stack_shrink_stack_905522432
mov r11, qword PVAR(rsi)
mov r10, r12
MAKE_PAIR(r12, r11, r10)
dec rsi
jmp create_opt_params_list_905522432
pop_and_adjust_stack_shrink_stack_905522432:
mov rsi, 0
mov rdi, 0
mov rcx,0
mov rbx, 0
mov rdi, [rbp + 8]
mov rcx, [rbp + 8*2]
mov rsi, [rbp + 8*3]
add rsp, 32
mov rbx, 0
lea rbx, [rsi*8]
add rsp, rbx
push qword r12
mov r12, 0
mov r12, 0
dec r12
mov rbx, 0
shrink_push_non_optional_params_loop_905522432:
cmp rbx, r12
jbe end_shrink_push_non_optional_params_loop_905522432
push qword [r9 + 8*r12]
dec r12
jmp shrink_push_non_optional_params_loop_905522432
end_shrink_push_non_optional_params_loop_905522432:
mov r15, 0
dec r15
cmp r15, r12
je dont_push_905522432
push qword [r9 + 8*r12]
dont_push_905522432:
mov rsi, 0
mov rsi, 0
inc rsi
push rsi
push rcx
push rdi
jmp body_of_opt_905522432
enlarge_stack_905522432:
mov rsi, 0
mov rdi, 0
mov rcx,0
mov rbx, 0
mov rdx, 0
mov rdx, qword [rbp + 8*3]
mov rdi, [rbp + 8]
mov rcx, [rbp + 8*2]
mov rsi, [rbp + 8*3]
add rsp, 32
lea rbx, [rsi*8]
add rsp, rbx
push SOB_NIL_ADDRESS
mov r10, 0
mov r11, 0
mov r10, rsi
dec r10
mov rbx, 0
enlarge_push_non_optional_params_loop_905522432:
cmp rbx, r10
jb end_enlarge_push_non_optional_params_loop_905522432
push qword [r9 + 8*r10]
dec r10
jmp enlarge_push_non_optional_params_loop_905522432
end_enlarge_push_non_optional_params_loop_905522432:
mov rsi, rdx
inc rsi
push rsi
push rcx
push rdi
body_of_opt_905522432:
push rbp
mov rbp, rsp

push SOB_NIL_ADDRESS

mov rax, const_tbl+1

push rax

mov qword rax, [rbp + 32]

push rax

push 2
mov rax, qword [fvar_tbl + 8*16]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_98100301:

cmp rax, SOB_FALSE_ADDRESS
je Lelse_395313404
mov qword rax, [rbp + 32]

jmp Lexit_640034938
Lelse_395313404:

push SOB_NIL_ADDRESS

mov rax, const_tbl+32

push rax


push SOB_NIL_ADDRESS

mov qword rax, [rbp + 32]

push rax

push 1
mov rax, qword [fvar_tbl + 8*34]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_44907061:

push rax

push 2
mov rax, qword [fvar_tbl + 8*22]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_565297347:

cmp rax, SOB_FALSE_ADDRESS
je Lelse_326105067

push SOB_NIL_ADDRESS

mov qword rax, [rbp + 32]

push rax

push 1
mov rax, qword [fvar_tbl + 8*23]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_285021971:

jmp Lexit_409307569
Lelse_326105067:

push SOB_NIL_ADDRESS


push SOB_NIL_ADDRESS

mov qword rax, [rbp + 32]

push rax

push 1
mov rax, qword [fvar_tbl + 8*32]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_937227572:

push rax

push 1

mov rsi, [rbp + 8 * 3]			;; (*rsi holds the number of parametres on the stack*)
inc rsi
lea rsi, [rsi * 8]
MALLOC rdx, rsi			;; (*now rdx points to the allocated memory for the new vector*)
mov rcx, [rbp + 8 * 3]
mov rdi, 0			;;(*rdi will be used to point to the next address in the vector*)

mov r9, 4
;; (*start of loop to copy parameters to the new allocated vector*)
copy_params_loop_274455462:
cmp rdi, rcx
je after_params_copy_274455462
mov rsi, [rbp + 8 * r9]			;;(*now rsi points to the next parameter on the stack*)
mov [rdx + 8*rdi], rsi			;;(*copying the parameter to the new allocated vector*)
inc rdi
inc r9
jmp copy_params_loop_274455462
;; (*now rdx points to the new vector to be added to ext_env*)
;; (*mov 0 to all neccessary registers*)
after_params_copy_274455462:
mov qword [rdx + 8*rdi], SOB_NIL_ADDRESS
mov rcx, 0
mov rdi, 0
mov rsi, 0
;; (*now we need to create ext_env by copying env and adding the new vector*)
MALLOC rbx, 16			;;(*rbx points to a new allocated space for ext_env*)
mov [rbx], rdx			;;(*coping the new vector to ext_env[0]*)
mov rsi, [rbp + 8 * 2]			;;(*rsi points to current env*)
mov rcx, 1			;;(*rcx is the loop counter*)
mov r9, 0			;;(*r9 will be used to point to the next vector in current env to be copied*)
mov rdi, 1			;;(*rdi will be used to point to the next address in ext_env*)
mov r8, 0
;; (*start of loop for copying env[i] to ext_env[i+1]*)
copy_env_loop_274455462:
cmp r9, rcx
je after_env_copy_274455462
mov r8, [rsi + 8 * r9]			;;(*r8 points to the next vector int current env to be copied*) 
mov [rbx + 8 * rdi], r8			;;(*copying the pointer to the vector from env to ext_env*)
inc r9
inc rdi
jmp copy_env_loop_274455462
after_env_copy_274455462:

MAKE_CLOSURE(rax, rbx, Lcode_274455462)
jmp Lcont_274455462
Lcode_274455462:
push rbp
mov rbp, rsp

push SOB_NIL_ADDRESS


push SOB_NIL_ADDRESS


push SOB_NIL_ADDRESS

mov qword rax, [rbp + 32]

push rax

push 1
mov rax, qword [fvar_tbl + 8*24]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_832502760:

push rax

push 1
mov rax, qword [fvar_tbl + 8*32]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_566618411:

push rax


push SOB_NIL_ADDRESS

mov qword rax, [rbp + 32]

push rax

push 1
mov rax, qword [fvar_tbl + 8*23]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_6123927:

push rax

mov rax, qword [fvar_tbl + 8*25]

push rax

push 3
mov rax, qword [fvar_tbl + 8*31]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_672812566:

leave
ret
Lcont_274455462:


push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_681013979:

Lexit_409307569:

Lexit_640034938:

leave
ret
Lcont_905522432:


mov [fvar_tbl + 8*33], rax
mov rax, SOB_VOID_ADDRESS
	call write_sob_if_not_void


push SOB_NIL_ADDRESS

mov rax, qword [fvar_tbl + 8*25]

push rax

mov rax, qword [fvar_tbl + 8*31]

push rax

mov rax, qword [fvar_tbl + 8*4]

push rax

push 3
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode_115132095)
jmp Lcont_115132095
Lcode_115132095:
push rbp
mov rbp, rsp

mov rsi, [rbp + 8 * 3]			;; (*rsi holds the number of parametres on the stack*)
inc rsi
lea rsi, [rsi * 8]
MALLOC rdx, rsi			;; (*now rdx points to the allocated memory for the new vector*)
mov rcx, [rbp + 8 * 3]
mov rdi, 0			;;(*rdi will be used to point to the next address in the vector*)

mov r9, 4
;; (*start of loop to copy parameters to the new allocated vector*)
copy_params_loop_408226969:
cmp rdi, rcx
je after_params_copy_408226969
mov rsi, [rbp + 8 * r9]			;;(*now rsi points to the next parameter on the stack*)
mov [rdx + 8*rdi], rsi			;;(*copying the parameter to the new allocated vector*)
inc rdi
inc r9
jmp copy_params_loop_408226969
;; (*now rdx points to the new vector to be added to ext_env*)
;; (*mov 0 to all neccessary registers*)
after_params_copy_408226969:
mov qword [rdx + 8*rdi], SOB_NIL_ADDRESS
mov rcx, 0
mov rdi, 0
mov rsi, 0
;; (*now we need to create ext_env by copying env and adding the new vector*)
MALLOC rbx, 16			;;(*rbx points to a new allocated space for ext_env*)
mov [rbx], rdx			;;(*copying the new vector to ext_env[0]*)
mov rsi, [rbp + 8 * 2]			;;(*rsi points to current env*)
mov rcx, 1			;;(*rcx is the loop counter*)
mov r9, 0			;;(*r9 will be used to point to the next vector in current env to be copied*)
mov rdi, 1			;;(*rdi will be used to point to the next address in ext_env*)
mov r8, 0
;; (*start of loop for copying env[i] to ext_env[i+1]*)
copy_env_loop_408226969:
cmp r9, rcx
je after_env_copy_408226969
mov r8, [rsi + 8 * r9]			;;(*r8 points to the next vector int current env to be copied*) 
mov [rbx + 8 * rdi], r8			;;(*copying the pointer to the vector from env to ext_env*)
inc r9
inc rdi
jmp copy_env_loop_408226969
after_env_copy_408226969:

MAKE_CLOSURE(rax, rbx, Lcode_408226969)
jmp Lcont_408226969
Lcode_408226969:
push rbp
mov rbp, rsp
mov rdi, 0
mov rsi, qword [rbp + 8*3]
cmp qword rdi, rsi
jb vector_size_is_total_num_of_params_408226969
mov rsi, 0
mov rsi, 0
jmp create_vector_408226969
vector_size_is_total_num_of_params_408226969:
mov rsi, [rbp + 8*3]
create_vector_408226969:
lea rsi, [rsi*8]
mov r9, 0
mov rbx, 0
mov rdx, 0
MALLOC r9, rsi
mov rsi, 0
mov rsi, 0
mov rcx, 0
copy_non_opt_params_list_for_opt_408226969:
cmp rcx, rsi
je end_copy_non_opt_params_list_for_opt_408226969
mov rbx, qword PVAR(rcx)
mov qword [r9 + 8 * rcx], rbx
inc rcx
jmp copy_non_opt_params_list_for_opt_408226969
end_copy_non_opt_params_list_for_opt_408226969:
mov rsi, [rbp + 8*3]
cmp rsi, 0
je enlarge_stack_408226969
shrink_stack_408226969:
mov rdi, 0
dec rsi
mov r12, 0
mov r11, 0
mov r10, 0
mov r11, PVAR(rsi)
dec rsi
MAKE_PAIR(r12, r11, SOB_NIL_ADDRESS)
dec rdi
create_opt_params_list_408226969:
cmp rdi, rsi
je pop_and_adjust_stack_shrink_stack_408226969
mov r11, qword PVAR(rsi)
mov r10, r12
MAKE_PAIR(r12, r11, r10)
dec rsi
jmp create_opt_params_list_408226969
pop_and_adjust_stack_shrink_stack_408226969:
mov rsi, 0
mov rdi, 0
mov rcx,0
mov rbx, 0
mov rdi, [rbp + 8]
mov rcx, [rbp + 8*2]
mov rsi, [rbp + 8*3]
add rsp, 32
mov rbx, 0
lea rbx, [rsi*8]
add rsp, rbx
push qword r12
mov r12, 0
mov r12, 0
dec r12
mov rbx, 0
shrink_push_non_optional_params_loop_408226969:
cmp rbx, r12
jbe end_shrink_push_non_optional_params_loop_408226969
push qword [r9 + 8*r12]
dec r12
jmp shrink_push_non_optional_params_loop_408226969
end_shrink_push_non_optional_params_loop_408226969:
mov r15, 0
dec r15
cmp r15, r12
je dont_push_408226969
push qword [r9 + 8*r12]
dont_push_408226969:
mov rsi, 0
mov rsi, 0
inc rsi
push rsi
push rcx
push rdi
jmp body_of_opt_408226969
enlarge_stack_408226969:
mov rsi, 0
mov rdi, 0
mov rcx,0
mov rbx, 0
mov rdx, 0
mov rdx, qword [rbp + 8*3]
mov rdi, [rbp + 8]
mov rcx, [rbp + 8*2]
mov rsi, [rbp + 8*3]
add rsp, 32
lea rbx, [rsi*8]
add rsp, rbx
push SOB_NIL_ADDRESS
mov r10, 0
mov r11, 0
mov r10, rsi
dec r10
mov rbx, 0
enlarge_push_non_optional_params_loop_408226969:
cmp rbx, r10
jb end_enlarge_push_non_optional_params_loop_408226969
push qword [r9 + 8*r10]
dec r10
jmp enlarge_push_non_optional_params_loop_408226969
end_enlarge_push_non_optional_params_loop_408226969:
mov rsi, rdx
inc rsi
push rsi
push rcx
push rdi
body_of_opt_408226969:
push rbp
mov rbp, rsp

push SOB_NIL_ADDRESS

mov qword rax, [rbp + 32]

push rax

mov rax, const_tbl+1

push rax


mov rsi, [rbp + 8 * 3]			;; (*rsi holds the number of parametres on the stack*)
inc rsi
lea rsi, [rsi * 8]
MALLOC rdx, rsi			;; (*now rdx points to the allocated memory for the new vector*)
mov rcx, [rbp + 8 * 3]
mov rdi, 0			;;(*rdi will be used to point to the next address in the vector*)

mov r9, 4
;; (*start of loop to copy parameters to the new allocated vector*)
copy_params_loop_301578941:
cmp rdi, rcx
je after_params_copy_301578941
mov rsi, [rbp + 8 * r9]			;;(*now rsi points to the next parameter on the stack*)
mov [rdx + 8*rdi], rsi			;;(*copying the parameter to the new allocated vector*)
inc rdi
inc r9
jmp copy_params_loop_301578941
;; (*now rdx points to the new vector to be added to ext_env*)
;; (*mov 0 to all neccessary registers*)
after_params_copy_301578941:
mov qword [rdx + 8*rdi], SOB_NIL_ADDRESS
mov rcx, 0
mov rdi, 0
mov rsi, 0
;; (*now we need to create ext_env by copying env and adding the new vector*)
MALLOC rbx, 24			;;(*rbx points to a new allocated space for ext_env*)
mov [rbx], rdx			;;(*coping the new vector to ext_env[0]*)
mov rsi, [rbp + 8 * 2]			;;(*rsi points to current env*)
mov rcx, 2			;;(*rcx is the loop counter*)
mov r9, 0			;;(*r9 will be used to point to the next vector in current env to be copied*)
mov rdi, 1			;;(*rdi will be used to point to the next address in ext_env*)
mov r8, 0
;; (*start of loop for copying env[i] to ext_env[i+1]*)
copy_env_loop_301578941:
cmp r9, rcx
je after_env_copy_301578941
mov r8, [rsi + 8 * r9]			;;(*r8 points to the next vector int current env to be copied*) 
mov [rbx + 8 * rdi], r8			;;(*copying the pointer to the vector from env to ext_env*)
inc r9
inc rdi
jmp copy_env_loop_301578941
after_env_copy_301578941:

MAKE_CLOSURE(rax, rbx, Lcode_301578941)
jmp Lcont_301578941
Lcode_301578941:
push rbp
mov rbp, rsp

push SOB_NIL_ADDRESS

mov qword rax, [rbp + 40]

push rax

push 1
mov rax, qword [rbp + 16]
mov rax, qword [rax + 8]
mov rax, qword [rax + 0]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_866852534:

cmp rax, SOB_FALSE_ADDRESS
je Lelse_658392294
mov qword rax, [rbp + 32]

jmp Lexit_732603925
Lelse_658392294:

push SOB_NIL_ADDRESS

mov qword rax, [rbp + 32]

push rax

mov qword rax, [rbp + 40]

push rax

mov rax, qword [rbp + 16]
mov rax, qword [rax + 8]
mov rax, qword [rax + 16]

push rax

push 3
mov rax, qword [rbp + 16]
mov rax, qword [rax + 8]
mov rax, qword [rax + 8]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_808498156:

Lexit_732603925:

leave
ret
Lcont_301578941:


push rax

push 3
mov rax, qword [rbp + 16]
mov rax, qword [rax + 0]
mov rax, qword [rax + 8]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_513666613:

leave
ret
Lcont_408226969:


leave
ret
Lcont_115132095:


push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_246489982:

mov [fvar_tbl + 8*35], rax
mov rax, SOB_VOID_ADDRESS
	call write_sob_if_not_void

MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode_735962992)
jmp Lcont_735962992
Lcode_735962992:
push rbp
mov rbp, rsp
mov rdi, 0
mov rsi, qword [rbp + 8*3]
cmp qword rdi, rsi
jb vector_size_is_total_num_of_params_735962992
mov rsi, 0
mov rsi, 0
jmp create_vector_735962992
vector_size_is_total_num_of_params_735962992:
mov rsi, [rbp + 8*3]
create_vector_735962992:
lea rsi, [rsi*8]
mov r9, 0
mov rbx, 0
mov rdx, 0
MALLOC r9, rsi
mov rsi, 0
mov rsi, 0
mov rcx, 0
copy_non_opt_params_list_for_opt_735962992:
cmp rcx, rsi
je end_copy_non_opt_params_list_for_opt_735962992
mov rbx, qword PVAR(rcx)
mov qword [r9 + 8 * rcx], rbx
inc rcx
jmp copy_non_opt_params_list_for_opt_735962992
end_copy_non_opt_params_list_for_opt_735962992:
mov rsi, [rbp + 8*3]
cmp rsi, 0
je enlarge_stack_735962992
shrink_stack_735962992:
mov rdi, 0
dec rsi
mov r12, 0
mov r11, 0
mov r10, 0
mov r11, PVAR(rsi)
dec rsi
MAKE_PAIR(r12, r11, SOB_NIL_ADDRESS)
dec rdi
create_opt_params_list_735962992:
cmp rdi, rsi
je pop_and_adjust_stack_shrink_stack_735962992
mov r11, qword PVAR(rsi)
mov r10, r12
MAKE_PAIR(r12, r11, r10)
dec rsi
jmp create_opt_params_list_735962992
pop_and_adjust_stack_shrink_stack_735962992:
mov rsi, 0
mov rdi, 0
mov rcx,0
mov rbx, 0
mov rdi, [rbp + 8]
mov rcx, [rbp + 8*2]
mov rsi, [rbp + 8*3]
add rsp, 32
mov rbx, 0
lea rbx, [rsi*8]
add rsp, rbx
push qword r12
mov r12, 0
mov r12, 0
dec r12
mov rbx, 0
shrink_push_non_optional_params_loop_735962992:
cmp rbx, r12
jbe end_shrink_push_non_optional_params_loop_735962992
push qword [r9 + 8*r12]
dec r12
jmp shrink_push_non_optional_params_loop_735962992
end_shrink_push_non_optional_params_loop_735962992:
mov r15, 0
dec r15
cmp r15, r12
je dont_push_735962992
push qword [r9 + 8*r12]
dont_push_735962992:
mov rsi, 0
mov rsi, 0
inc rsi
push rsi
push rcx
push rdi
jmp body_of_opt_735962992
enlarge_stack_735962992:
mov rsi, 0
mov rdi, 0
mov rcx,0
mov rbx, 0
mov rdx, 0
mov rdx, qword [rbp + 8*3]
mov rdi, [rbp + 8]
mov rcx, [rbp + 8*2]
mov rsi, [rbp + 8*3]
add rsp, 32
lea rbx, [rsi*8]
add rsp, rbx
push SOB_NIL_ADDRESS
mov r10, 0
mov r11, 0
mov r10, rsi
dec r10
mov rbx, 0
enlarge_push_non_optional_params_loop_735962992:
cmp rbx, r10
jb end_enlarge_push_non_optional_params_loop_735962992
push qword [r9 + 8*r10]
dec r10
jmp enlarge_push_non_optional_params_loop_735962992
end_enlarge_push_non_optional_params_loop_735962992:
mov rsi, rdx
inc rsi
push rsi
push rcx
push rdi
body_of_opt_735962992:
push rbp
mov rbp, rsp
mov qword rax, [rbp + 32]

leave
ret
Lcont_735962992:


mov [fvar_tbl + 8*36], rax
mov rax, SOB_VOID_ADDRESS
	call write_sob_if_not_void


push SOB_NIL_ADDRESS

mov rax, qword [fvar_tbl + 8*24]

push rax

mov rax, qword [fvar_tbl + 8*3]

push rax

mov rax, qword [fvar_tbl + 8*4]

push rax

push 3
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode_142687140)
jmp Lcont_142687140
Lcode_142687140:
push rbp
mov rbp, rsp

push SOB_NIL_ADDRESS

mov rax, const_tbl+23

push rax

push 1

mov rsi, [rbp + 8 * 3]			;; (*rsi holds the number of parametres on the stack*)
inc rsi
lea rsi, [rsi * 8]
MALLOC rdx, rsi			;; (*now rdx points to the allocated memory for the new vector*)
mov rcx, [rbp + 8 * 3]
mov rdi, 0			;;(*rdi will be used to point to the next address in the vector*)

mov r9, 4
;; (*start of loop to copy parameters to the new allocated vector*)
copy_params_loop_196223014:
cmp rdi, rcx
je after_params_copy_196223014
mov rsi, [rbp + 8 * r9]			;;(*now rsi points to the next parameter on the stack*)
mov [rdx + 8*rdi], rsi			;;(*copying the parameter to the new allocated vector*)
inc rdi
inc r9
jmp copy_params_loop_196223014
;; (*now rdx points to the new vector to be added to ext_env*)
;; (*mov 0 to all neccessary registers*)
after_params_copy_196223014:
mov qword [rdx + 8*rdi], SOB_NIL_ADDRESS
mov rcx, 0
mov rdi, 0
mov rsi, 0
;; (*now we need to create ext_env by copying env and adding the new vector*)
MALLOC rbx, 16			;;(*rbx points to a new allocated space for ext_env*)
mov [rbx], rdx			;;(*coping the new vector to ext_env[0]*)
mov rsi, [rbp + 8 * 2]			;;(*rsi points to current env*)
mov rcx, 1			;;(*rcx is the loop counter*)
mov r9, 0			;;(*r9 will be used to point to the next vector in current env to be copied*)
mov rdi, 1			;;(*rdi will be used to point to the next address in ext_env*)
mov r8, 0
;; (*start of loop for copying env[i] to ext_env[i+1]*)
copy_env_loop_196223014:
cmp r9, rcx
je after_env_copy_196223014
mov r8, [rsi + 8 * r9]			;;(*r8 points to the next vector int current env to be copied*) 
mov [rbx + 8 * rdi], r8			;;(*copying the pointer to the vector from env to ext_env*)
inc r9
inc rdi
jmp copy_env_loop_196223014
after_env_copy_196223014:

MAKE_CLOSURE(rax, rbx, Lcode_196223014)
jmp Lcont_196223014
Lcode_196223014:
push rbp
mov rbp, rsp


mov rsi, [rbp + 8 * 3]			;; (*rsi holds the number of parametres on the stack*)
inc rsi
lea rsi, [rsi * 8]
MALLOC rdx, rsi			;; (*now rdx points to the allocated memory for the new vector*)
mov rcx, [rbp + 8 * 3]
mov rdi, 0			;;(*rdi will be used to point to the next address in the vector*)

mov r9, 4
;; (*start of loop to copy parameters to the new allocated vector*)
copy_params_loop_170783178:
cmp rdi, rcx
je after_params_copy_170783178
mov rsi, [rbp + 8 * r9]			;;(*now rsi points to the next parameter on the stack*)
mov [rdx + 8*rdi], rsi			;;(*copying the parameter to the new allocated vector*)
inc rdi
inc r9
jmp copy_params_loop_170783178
;; (*now rdx points to the new vector to be added to ext_env*)
;; (*mov 0 to all neccessary registers*)
after_params_copy_170783178:
mov qword [rdx + 8*rdi], SOB_NIL_ADDRESS
mov rcx, 0
mov rdi, 0
mov rsi, 0
;; (*now we need to create ext_env by copying env and adding the new vector*)
MALLOC rbx, 24			;;(*rbx points to a new allocated space for ext_env*)
mov [rbx], rdx			;;(*coping the new vector to ext_env[0]*)
mov rsi, [rbp + 8 * 2]			;;(*rsi points to current env*)
mov rcx, 2			;;(*rcx is the loop counter*)
mov r9, 0			;;(*r9 will be used to point to the next vector in current env to be copied*)
mov rdi, 1			;;(*rdi will be used to point to the next address in ext_env*)
mov r8, 0
;; (*start of loop for copying env[i] to ext_env[i+1]*)
copy_env_loop_170783178:
cmp r9, rcx
je after_env_copy_170783178
mov r8, [rsi + 8 * r9]			;;(*r8 points to the next vector int current env to be copied*) 
mov [rbx + 8 * rdi], r8			;;(*copying the pointer to the vector from env to ext_env*)
inc r9
inc rdi
jmp copy_env_loop_170783178
after_env_copy_170783178:

MAKE_CLOSURE(rax, rbx, Lcode_170783178)
jmp Lcont_170783178
Lcode_170783178:
push rbp
mov rbp, rsp

push SOB_NIL_ADDRESS

mov qword rax, [rbp + 32]

push rax

push 1
mov rax, qword [rbp + 16]
mov rax, qword [rax + 8]
mov rax, qword [rax + 0]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_230494162:

cmp rax, SOB_FALSE_ADDRESS
jne Lexit_700349737

push SOB_NIL_ADDRESS

mov qword rax, [rbp + 32]

push rax

push 1
mov rax, qword [rbp + 16]
mov rax, qword [rax + 8]
mov rax, qword [rax + 8]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_661528186:

cmp rax, SOB_FALSE_ADDRESS
je Lelse_323318772

push SOB_NIL_ADDRESS


push SOB_NIL_ADDRESS

mov qword rax, [rbp + 32]

push rax

push 1
mov rax, qword [rbp + 16]
mov rax, qword [rax + 8]
mov rax, qword [rax + 16]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_107290671:

push rax

push 1
mov rax, qword [fvar_tbl + 8*37]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_96734197:

jmp Lexit_359421285
Lelse_323318772:
mov rax, const_tbl+2

Lexit_359421285:

Lexit_700349737:

leave
ret
Lcont_170783178:


mov qword [rbp + 32], rax
mov rax, SOB_VOID_ADDRESS


mov qword rax, [rbp + 32]


leave
ret
Lcont_196223014:


push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_337561787:

leave
ret
Lcont_142687140:


push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_478170254:

mov [fvar_tbl + 8*37], rax
mov rax, SOB_VOID_ADDRESS
	call write_sob_if_not_void


push SOB_NIL_ADDRESS

mov rax, qword [fvar_tbl + 8*17]

push rax

mov rax, qword [fvar_tbl + 8*30]

push rax

push 2
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode_260383377)
jmp Lcont_260383377
Lcode_260383377:
push rbp
mov rbp, rsp

mov rsi, [rbp + 8 * 3]			;; (*rsi holds the number of parametres on the stack*)
inc rsi
lea rsi, [rsi * 8]
MALLOC rdx, rsi			;; (*now rdx points to the allocated memory for the new vector*)
mov rcx, [rbp + 8 * 3]
mov rdi, 0			;;(*rdi will be used to point to the next address in the vector*)

mov r9, 4
;; (*start of loop to copy parameters to the new allocated vector*)
copy_params_loop_798031681:
cmp rdi, rcx
je after_params_copy_798031681
mov rsi, [rbp + 8 * r9]			;;(*now rsi points to the next parameter on the stack*)
mov [rdx + 8*rdi], rsi			;;(*copying the parameter to the new allocated vector*)
inc rdi
inc r9
jmp copy_params_loop_798031681
;; (*now rdx points to the new vector to be added to ext_env*)
;; (*mov 0 to all neccessary registers*)
after_params_copy_798031681:
mov qword [rdx + 8*rdi], SOB_NIL_ADDRESS
mov rcx, 0
mov rdi, 0
mov rsi, 0
;; (*now we need to create ext_env by copying env and adding the new vector*)
MALLOC rbx, 16			;;(*rbx points to a new allocated space for ext_env*)
mov [rbx], rdx			;;(*coping the new vector to ext_env[0]*)
mov rsi, [rbp + 8 * 2]			;;(*rsi points to current env*)
mov rcx, 1			;;(*rcx is the loop counter*)
mov r9, 0			;;(*r9 will be used to point to the next vector in current env to be copied*)
mov rdi, 1			;;(*rdi will be used to point to the next address in ext_env*)
mov r8, 0
;; (*start of loop for copying env[i] to ext_env[i+1]*)
copy_env_loop_798031681:
cmp r9, rcx
je after_env_copy_798031681
mov r8, [rsi + 8 * r9]			;;(*r8 points to the next vector int current env to be copied*) 
mov [rbx + 8 * rdi], r8			;;(*copying the pointer to the vector from env to ext_env*)
inc r9
inc rdi
jmp copy_env_loop_798031681
after_env_copy_798031681:

MAKE_CLOSURE(rax, rbx, Lcode_798031681)
jmp Lcont_798031681
Lcode_798031681:
push rbp
mov rbp, rsp

push SOB_NIL_ADDRESS

mov qword rax, [rbp + 32]

push rax

mov rax, const_tbl+41

push rax


mov rsi, [rbp + 8 * 3]			;; (*rsi holds the number of parametres on the stack*)
inc rsi
lea rsi, [rsi * 8]
MALLOC rdx, rsi			;; (*now rdx points to the allocated memory for the new vector*)
mov rcx, [rbp + 8 * 3]
mov rdi, 0			;;(*rdi will be used to point to the next address in the vector*)

mov r9, 4
;; (*start of loop to copy parameters to the new allocated vector*)
copy_params_loop_888483189:
cmp rdi, rcx
je after_params_copy_888483189
mov rsi, [rbp + 8 * r9]			;;(*now rsi points to the next parameter on the stack*)
mov [rdx + 8*rdi], rsi			;;(*copying the parameter to the new allocated vector*)
inc rdi
inc r9
jmp copy_params_loop_888483189
;; (*now rdx points to the new vector to be added to ext_env*)
;; (*mov 0 to all neccessary registers*)
after_params_copy_888483189:
mov qword [rdx + 8*rdi], SOB_NIL_ADDRESS
mov rcx, 0
mov rdi, 0
mov rsi, 0
;; (*now we need to create ext_env by copying env and adding the new vector*)
MALLOC rbx, 24			;;(*rbx points to a new allocated space for ext_env*)
mov [rbx], rdx			;;(*coping the new vector to ext_env[0]*)
mov rsi, [rbp + 8 * 2]			;;(*rsi points to current env*)
mov rcx, 2			;;(*rcx is the loop counter*)
mov r9, 0			;;(*r9 will be used to point to the next vector in current env to be copied*)
mov rdi, 1			;;(*rdi will be used to point to the next address in ext_env*)
mov r8, 0
;; (*start of loop for copying env[i] to ext_env[i+1]*)
copy_env_loop_888483189:
cmp r9, rcx
je after_env_copy_888483189
mov r8, [rsi + 8 * r9]			;;(*r8 points to the next vector int current env to be copied*) 
mov [rbx + 8 * rdi], r8			;;(*copying the pointer to the vector from env to ext_env*)
inc r9
inc rdi
jmp copy_env_loop_888483189
after_env_copy_888483189:

MAKE_CLOSURE(rax, rbx, Lcode_888483189)
jmp Lcont_888483189
Lcode_888483189:
push rbp
mov rbp, rsp

push SOB_NIL_ADDRESS

mov rax, const_tbl+32

push rax

mov qword rax, [rbp + 32]

push rax

push 2
mov rax, qword [rbp + 16]
mov rax, qword [rax + 8]
mov rax, qword [rax + 8]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_929852288:

leave
ret
Lcont_888483189:


push rax

push 3
mov rax, qword [rbp + 16]
mov rax, qword [rax + 0]
mov rax, qword [rax + 0]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_284101271:

leave
ret
Lcont_798031681:


leave
ret
Lcont_260383377:


push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_909437959:

mov [fvar_tbl + 8*34], rax
mov rax, SOB_VOID_ADDRESS
	call write_sob_if_not_void


push SOB_NIL_ADDRESS

mov rax, qword [fvar_tbl + 8*12]

push rax

mov rax, qword [fvar_tbl + 8*23]

push rax

mov rax, qword [fvar_tbl + 8*4]

push rax

push 3
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode_267491446)
jmp Lcont_267491446
Lcode_267491446:
push rbp
mov rbp, rsp

mov rsi, [rbp + 8 * 3]			;; (*rsi holds the number of parametres on the stack*)
inc rsi
lea rsi, [rsi * 8]
MALLOC rdx, rsi			;; (*now rdx points to the allocated memory for the new vector*)
mov rcx, [rbp + 8 * 3]
mov rdi, 0			;;(*rdi will be used to point to the next address in the vector*)

mov r9, 4
;; (*start of loop to copy parameters to the new allocated vector*)
copy_params_loop_255480485:
cmp rdi, rcx
je after_params_copy_255480485
mov rsi, [rbp + 8 * r9]			;;(*now rsi points to the next parameter on the stack*)
mov [rdx + 8*rdi], rsi			;;(*copying the parameter to the new allocated vector*)
inc rdi
inc r9
jmp copy_params_loop_255480485
;; (*now rdx points to the new vector to be added to ext_env*)
;; (*mov 0 to all neccessary registers*)
after_params_copy_255480485:
mov qword [rdx + 8*rdi], SOB_NIL_ADDRESS
mov rcx, 0
mov rdi, 0
mov rsi, 0
;; (*now we need to create ext_env by copying env and adding the new vector*)
MALLOC rbx, 16			;;(*rbx points to a new allocated space for ext_env*)
mov [rbx], rdx			;;(*copying the new vector to ext_env[0]*)
mov rsi, [rbp + 8 * 2]			;;(*rsi points to current env*)
mov rcx, 1			;;(*rcx is the loop counter*)
mov r9, 0			;;(*r9 will be used to point to the next vector in current env to be copied*)
mov rdi, 1			;;(*rdi will be used to point to the next address in ext_env*)
mov r8, 0
;; (*start of loop for copying env[i] to ext_env[i+1]*)
copy_env_loop_255480485:
cmp r9, rcx
je after_env_copy_255480485
mov r8, [rsi + 8 * r9]			;;(*r8 points to the next vector int current env to be copied*) 
mov [rbx + 8 * rdi], r8			;;(*copying the pointer to the vector from env to ext_env*)
inc r9
inc rdi
jmp copy_env_loop_255480485
after_env_copy_255480485:

MAKE_CLOSURE(rax, rbx, Lcode_255480485)
jmp Lcont_255480485
Lcode_255480485:
push rbp
mov rbp, rsp
mov rdi, 1
mov rsi, qword [rbp + 8*3]
cmp qword rdi, rsi
jb vector_size_is_total_num_of_params_255480485
mov rsi, 0
mov rsi, 1
jmp create_vector_255480485
vector_size_is_total_num_of_params_255480485:
mov rsi, [rbp + 8*3]
create_vector_255480485:
lea rsi, [rsi*8]
mov r9, 0
mov rbx, 0
mov rdx, 0
MALLOC r9, rsi
mov rsi, 0
mov rsi, 1
mov rcx, 0
copy_non_opt_params_list_for_opt_255480485:
cmp rcx, rsi
je end_copy_non_opt_params_list_for_opt_255480485
mov rbx, qword PVAR(rcx)
mov qword [r9 + 8 * rcx], rbx
inc rcx
jmp copy_non_opt_params_list_for_opt_255480485
end_copy_non_opt_params_list_for_opt_255480485:
mov rsi, [rbp + 8*3]
cmp rsi, 1
je enlarge_stack_255480485
shrink_stack_255480485:
mov rdi, 1
dec rsi
mov r12, 0
mov r11, 0
mov r10, 0
mov r11, PVAR(rsi)
dec rsi
MAKE_PAIR(r12, r11, SOB_NIL_ADDRESS)
dec rdi
create_opt_params_list_255480485:
cmp rdi, rsi
je pop_and_adjust_stack_shrink_stack_255480485
mov r11, qword PVAR(rsi)
mov r10, r12
MAKE_PAIR(r12, r11, r10)
dec rsi
jmp create_opt_params_list_255480485
pop_and_adjust_stack_shrink_stack_255480485:
mov rsi, 0
mov rdi, 0
mov rcx,0
mov rbx, 0
mov rdi, [rbp + 8]
mov rcx, [rbp + 8*2]
mov rsi, [rbp + 8*3]
add rsp, 32
mov rbx, 0
lea rbx, [rsi*8]
add rsp, rbx
push qword r12
mov r12, 0
mov r12, 1
dec r12
mov rbx, 0
shrink_push_non_optional_params_loop_255480485:
cmp rbx, r12
jbe end_shrink_push_non_optional_params_loop_255480485
push qword [r9 + 8*r12]
dec r12
jmp shrink_push_non_optional_params_loop_255480485
end_shrink_push_non_optional_params_loop_255480485:
mov r15, 0
dec r15
cmp r15, r12
je dont_push_255480485
push qword [r9 + 8*r12]
dont_push_255480485:
mov rsi, 0
mov rsi, 1
inc rsi
push rsi
push rcx
push rdi
jmp body_of_opt_255480485
enlarge_stack_255480485:
mov rsi, 0
mov rdi, 0
mov rcx,0
mov rbx, 0
mov rdx, 0
mov rdx, qword [rbp + 8*3]
mov rdi, [rbp + 8]
mov rcx, [rbp + 8*2]
mov rsi, [rbp + 8*3]
add rsp, 32
lea rbx, [rsi*8]
add rsp, rbx
push SOB_NIL_ADDRESS
mov r10, 0
mov r11, 0
mov r10, rsi
dec r10
mov rbx, 0
enlarge_push_non_optional_params_loop_255480485:
cmp rbx, r10
jb end_enlarge_push_non_optional_params_loop_255480485
push qword [r9 + 8*r10]
dec r10
jmp enlarge_push_non_optional_params_loop_255480485
end_enlarge_push_non_optional_params_loop_255480485:
mov rsi, rdx
inc rsi
push rsi
push rcx
push rdi
body_of_opt_255480485:
push rbp
mov rbp, rsp

push SOB_NIL_ADDRESS

mov qword rax, [rbp + 40]

push rax

push 1
mov rax, qword [rbp + 16]
mov rax, qword [rax + 0]
mov rax, qword [rax + 0]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_991642384:

cmp rax, SOB_FALSE_ADDRESS
je Lelse_77108180

push SOB_NIL_ADDRESS

mov rax, const_tbl+50

push rax

mov qword rax, [rbp + 32]

push rax

push 2
mov rax, qword [rbp + 16]
mov rax, qword [rax + 0]
mov rax, qword [rax + 16]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_725956947:

jmp Lexit_698193242
Lelse_77108180:

push SOB_NIL_ADDRESS


push SOB_NIL_ADDRESS

mov qword rax, [rbp + 40]

push rax

push 1
mov rax, qword [rbp + 16]
mov rax, qword [rax + 0]
mov rax, qword [rax + 8]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_976927359:

push rax

mov qword rax, [rbp + 32]

push rax

push 2
mov rax, qword [rbp + 16]
mov rax, qword [rax + 0]
mov rax, qword [rax + 16]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_763661805:

Lexit_698193242:

leave
ret
Lcont_255480485:


leave
ret
Lcont_267491446:


push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_402949384:

mov [fvar_tbl + 8*12], rax
mov rax, SOB_VOID_ADDRESS
	call write_sob_if_not_void

MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode_572162651)
jmp Lcont_572162651
Lcode_572162651:
push rbp
mov rbp, rsp
mov qword rax, [rbp + 32]

cmp rax, SOB_FALSE_ADDRESS
je Lelse_698633168
mov rax, const_tbl+2

jmp Lexit_57534567
Lelse_698633168:
mov rax, const_tbl+4

Lexit_57534567:

leave
ret
Lcont_572162651:


mov [fvar_tbl + 8*38], rax
mov rax, SOB_VOID_ADDRESS
	call write_sob_if_not_void


push SOB_NIL_ADDRESS

mov rax, qword [fvar_tbl + 8*2]

push rax

mov rax, qword [fvar_tbl + 8*1]

push rax

push 2
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode_468792198)
jmp Lcont_468792198
Lcode_468792198:
push rbp
mov rbp, rsp

mov rsi, [rbp + 8 * 3]			;; (*rsi holds the number of parametres on the stack*)
inc rsi
lea rsi, [rsi * 8]
MALLOC rdx, rsi			;; (*now rdx points to the allocated memory for the new vector*)
mov rcx, [rbp + 8 * 3]
mov rdi, 0			;;(*rdi will be used to point to the next address in the vector*)

mov r9, 4
;; (*start of loop to copy parameters to the new allocated vector*)
copy_params_loop_746869368:
cmp rdi, rcx
je after_params_copy_746869368
mov rsi, [rbp + 8 * r9]			;;(*now rsi points to the next parameter on the stack*)
mov [rdx + 8*rdi], rsi			;;(*copying the parameter to the new allocated vector*)
inc rdi
inc r9
jmp copy_params_loop_746869368
;; (*now rdx points to the new vector to be added to ext_env*)
;; (*mov 0 to all neccessary registers*)
after_params_copy_746869368:
mov qword [rdx + 8*rdi], SOB_NIL_ADDRESS
mov rcx, 0
mov rdi, 0
mov rsi, 0
;; (*now we need to create ext_env by copying env and adding the new vector*)
MALLOC rbx, 16			;;(*rbx points to a new allocated space for ext_env*)
mov [rbx], rdx			;;(*coping the new vector to ext_env[0]*)
mov rsi, [rbp + 8 * 2]			;;(*rsi points to current env*)
mov rcx, 1			;;(*rcx is the loop counter*)
mov r9, 0			;;(*r9 will be used to point to the next vector in current env to be copied*)
mov rdi, 1			;;(*rdi will be used to point to the next address in ext_env*)
mov r8, 0
;; (*start of loop for copying env[i] to ext_env[i+1]*)
copy_env_loop_746869368:
cmp r9, rcx
je after_env_copy_746869368
mov r8, [rsi + 8 * r9]			;;(*r8 points to the next vector int current env to be copied*) 
mov [rbx + 8 * rdi], r8			;;(*copying the pointer to the vector from env to ext_env*)
inc r9
inc rdi
jmp copy_env_loop_746869368
after_env_copy_746869368:

MAKE_CLOSURE(rax, rbx, Lcode_746869368)
jmp Lcont_746869368
Lcode_746869368:
push rbp
mov rbp, rsp

push SOB_NIL_ADDRESS

mov qword rax, [rbp + 32]

push rax

push 1
mov rax, qword [rbp + 16]
mov rax, qword [rax + 0]
mov rax, qword [rax + 0]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_974805207:

cmp rax, SOB_FALSE_ADDRESS
jne Lexit_877236981

push SOB_NIL_ADDRESS

mov qword rax, [rbp + 32]

push rax

push 1
mov rax, qword [rbp + 16]
mov rax, qword [rax + 0]
mov rax, qword [rax + 8]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_34268921:

Lexit_877236981:

leave
ret
Lcont_746869368:


leave
ret
Lcont_468792198:


push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_44463351:

mov [fvar_tbl + 8*39], rax
mov rax, SOB_VOID_ADDRESS
	call write_sob_if_not_void


push SOB_NIL_ADDRESS

mov rax, qword [fvar_tbl + 8*17]

push rax

mov rax, qword [fvar_tbl + 8*30]

push rax

push 2
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode_926039712)
jmp Lcont_926039712
Lcode_926039712:
push rbp
mov rbp, rsp

mov rsi, [rbp + 8 * 3]			;; (*rsi holds the number of parametres on the stack*)
inc rsi
lea rsi, [rsi * 8]
MALLOC rdx, rsi			;; (*now rdx points to the allocated memory for the new vector*)
mov rcx, [rbp + 8 * 3]
mov rdi, 0			;;(*rdi will be used to point to the next address in the vector*)

mov r9, 4
;; (*start of loop to copy parameters to the new allocated vector*)
copy_params_loop_929236965:
cmp rdi, rcx
je after_params_copy_929236965
mov rsi, [rbp + 8 * r9]			;;(*now rsi points to the next parameter on the stack*)
mov [rdx + 8*rdi], rsi			;;(*copying the parameter to the new allocated vector*)
inc rdi
inc r9
jmp copy_params_loop_929236965
;; (*now rdx points to the new vector to be added to ext_env*)
;; (*mov 0 to all neccessary registers*)
after_params_copy_929236965:
mov qword [rdx + 8*rdi], SOB_NIL_ADDRESS
mov rcx, 0
mov rdi, 0
mov rsi, 0
;; (*now we need to create ext_env by copying env and adding the new vector*)
MALLOC rbx, 16			;;(*rbx points to a new allocated space for ext_env*)
mov [rbx], rdx			;;(*copying the new vector to ext_env[0]*)
mov rsi, [rbp + 8 * 2]			;;(*rsi points to current env*)
mov rcx, 1			;;(*rcx is the loop counter*)
mov r9, 0			;;(*r9 will be used to point to the next vector in current env to be copied*)
mov rdi, 1			;;(*rdi will be used to point to the next address in ext_env*)
mov r8, 0
;; (*start of loop for copying env[i] to ext_env[i+1]*)
copy_env_loop_929236965:
cmp r9, rcx
je after_env_copy_929236965
mov r8, [rsi + 8 * r9]			;;(*r8 points to the next vector int current env to be copied*) 
mov [rbx + 8 * rdi], r8			;;(*copying the pointer to the vector from env to ext_env*)
inc r9
inc rdi
jmp copy_env_loop_929236965
after_env_copy_929236965:

MAKE_CLOSURE(rax, rbx, Lcode_929236965)
jmp Lcont_929236965
Lcode_929236965:
push rbp
mov rbp, rsp
mov rdi, 0
mov rsi, qword [rbp + 8*3]
cmp qword rdi, rsi
jb vector_size_is_total_num_of_params_929236965
mov rsi, 0
mov rsi, 0
jmp create_vector_929236965
vector_size_is_total_num_of_params_929236965:
mov rsi, [rbp + 8*3]
create_vector_929236965:
lea rsi, [rsi*8]
mov r9, 0
mov rbx, 0
mov rdx, 0
MALLOC r9, rsi
mov rsi, 0
mov rsi, 0
mov rcx, 0
copy_non_opt_params_list_for_opt_929236965:
cmp rcx, rsi
je end_copy_non_opt_params_list_for_opt_929236965
mov rbx, qword PVAR(rcx)
mov qword [r9 + 8 * rcx], rbx
inc rcx
jmp copy_non_opt_params_list_for_opt_929236965
end_copy_non_opt_params_list_for_opt_929236965:
mov rsi, [rbp + 8*3]
cmp rsi, 0
je enlarge_stack_929236965
shrink_stack_929236965:
mov rdi, 0
dec rsi
mov r12, 0
mov r11, 0
mov r10, 0
mov r11, PVAR(rsi)
dec rsi
MAKE_PAIR(r12, r11, SOB_NIL_ADDRESS)
dec rdi
create_opt_params_list_929236965:
cmp rdi, rsi
je pop_and_adjust_stack_shrink_stack_929236965
mov r11, qword PVAR(rsi)
mov r10, r12
MAKE_PAIR(r12, r11, r10)
dec rsi
jmp create_opt_params_list_929236965
pop_and_adjust_stack_shrink_stack_929236965:
mov rsi, 0
mov rdi, 0
mov rcx,0
mov rbx, 0
mov rdi, [rbp + 8]
mov rcx, [rbp + 8*2]
mov rsi, [rbp + 8*3]
add rsp, 32
mov rbx, 0
lea rbx, [rsi*8]
add rsp, rbx
push qword r12
mov r12, 0
mov r12, 0
dec r12
mov rbx, 0
shrink_push_non_optional_params_loop_929236965:
cmp rbx, r12
jbe end_shrink_push_non_optional_params_loop_929236965
push qword [r9 + 8*r12]
dec r12
jmp shrink_push_non_optional_params_loop_929236965
end_shrink_push_non_optional_params_loop_929236965:
mov r15, 0
dec r15
cmp r15, r12
je dont_push_929236965
push qword [r9 + 8*r12]
dont_push_929236965:
mov rsi, 0
mov rsi, 0
inc rsi
push rsi
push rcx
push rdi
jmp body_of_opt_929236965
enlarge_stack_929236965:
mov rsi, 0
mov rdi, 0
mov rcx,0
mov rbx, 0
mov rdx, 0
mov rdx, qword [rbp + 8*3]
mov rdi, [rbp + 8]
mov rcx, [rbp + 8*2]
mov rsi, [rbp + 8*3]
add rsp, 32
lea rbx, [rsi*8]
add rsp, rbx
push SOB_NIL_ADDRESS
mov r10, 0
mov r11, 0
mov r10, rsi
dec r10
mov rbx, 0
enlarge_push_non_optional_params_loop_929236965:
cmp rbx, r10
jb end_enlarge_push_non_optional_params_loop_929236965
push qword [r9 + 8*r10]
dec r10
jmp enlarge_push_non_optional_params_loop_929236965
end_enlarge_push_non_optional_params_loop_929236965:
mov rsi, rdx
inc rsi
push rsi
push rcx
push rdi
body_of_opt_929236965:
push rbp
mov rbp, rsp

push SOB_NIL_ADDRESS

mov qword rax, [rbp + 32]

push rax

mov rax, const_tbl+41

push rax

mov rax, qword [rbp + 16]
mov rax, qword [rax + 0]
mov rax, qword [rax + 8]

push rax

push 3
mov rax, qword [rbp + 16]
mov rax, qword [rax + 0]
mov rax, qword [rax + 0]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_113414598:

leave
ret
Lcont_929236965:


leave
ret
Lcont_926039712:


push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_996131318:

mov [fvar_tbl + 8*17], rax
mov rax, SOB_VOID_ADDRESS
	call write_sob_if_not_void


push SOB_NIL_ADDRESS

mov rax, qword [fvar_tbl + 8*18]

push rax

mov rax, qword [fvar_tbl + 8*30]

push rax

push 2
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode_795791525)
jmp Lcont_795791525
Lcode_795791525:
push rbp
mov rbp, rsp

mov rsi, [rbp + 8 * 3]			;; (*rsi holds the number of parametres on the stack*)
inc rsi
lea rsi, [rsi * 8]
MALLOC rdx, rsi			;; (*now rdx points to the allocated memory for the new vector*)
mov rcx, [rbp + 8 * 3]
mov rdi, 0			;;(*rdi will be used to point to the next address in the vector*)

mov r9, 4
;; (*start of loop to copy parameters to the new allocated vector*)
copy_params_loop_954345019:
cmp rdi, rcx
je after_params_copy_954345019
mov rsi, [rbp + 8 * r9]			;;(*now rsi points to the next parameter on the stack*)
mov [rdx + 8*rdi], rsi			;;(*copying the parameter to the new allocated vector*)
inc rdi
inc r9
jmp copy_params_loop_954345019
;; (*now rdx points to the new vector to be added to ext_env*)
;; (*mov 0 to all neccessary registers*)
after_params_copy_954345019:
mov qword [rdx + 8*rdi], SOB_NIL_ADDRESS
mov rcx, 0
mov rdi, 0
mov rsi, 0
;; (*now we need to create ext_env by copying env and adding the new vector*)
MALLOC rbx, 16			;;(*rbx points to a new allocated space for ext_env*)
mov [rbx], rdx			;;(*copying the new vector to ext_env[0]*)
mov rsi, [rbp + 8 * 2]			;;(*rsi points to current env*)
mov rcx, 1			;;(*rcx is the loop counter*)
mov r9, 0			;;(*r9 will be used to point to the next vector in current env to be copied*)
mov rdi, 1			;;(*rdi will be used to point to the next address in ext_env*)
mov r8, 0
;; (*start of loop for copying env[i] to ext_env[i+1]*)
copy_env_loop_954345019:
cmp r9, rcx
je after_env_copy_954345019
mov r8, [rsi + 8 * r9]			;;(*r8 points to the next vector int current env to be copied*) 
mov [rbx + 8 * rdi], r8			;;(*copying the pointer to the vector from env to ext_env*)
inc r9
inc rdi
jmp copy_env_loop_954345019
after_env_copy_954345019:

MAKE_CLOSURE(rax, rbx, Lcode_954345019)
jmp Lcont_954345019
Lcode_954345019:
push rbp
mov rbp, rsp
mov rdi, 0
mov rsi, qword [rbp + 8*3]
cmp qword rdi, rsi
jb vector_size_is_total_num_of_params_954345019
mov rsi, 0
mov rsi, 0
jmp create_vector_954345019
vector_size_is_total_num_of_params_954345019:
mov rsi, [rbp + 8*3]
create_vector_954345019:
lea rsi, [rsi*8]
mov r9, 0
mov rbx, 0
mov rdx, 0
MALLOC r9, rsi
mov rsi, 0
mov rsi, 0
mov rcx, 0
copy_non_opt_params_list_for_opt_954345019:
cmp rcx, rsi
je end_copy_non_opt_params_list_for_opt_954345019
mov rbx, qword PVAR(rcx)
mov qword [r9 + 8 * rcx], rbx
inc rcx
jmp copy_non_opt_params_list_for_opt_954345019
end_copy_non_opt_params_list_for_opt_954345019:
mov rsi, [rbp + 8*3]
cmp rsi, 0
je enlarge_stack_954345019
shrink_stack_954345019:
mov rdi, 0
dec rsi
mov r12, 0
mov r11, 0
mov r10, 0
mov r11, PVAR(rsi)
dec rsi
MAKE_PAIR(r12, r11, SOB_NIL_ADDRESS)
dec rdi
create_opt_params_list_954345019:
cmp rdi, rsi
je pop_and_adjust_stack_shrink_stack_954345019
mov r11, qword PVAR(rsi)
mov r10, r12
MAKE_PAIR(r12, r11, r10)
dec rsi
jmp create_opt_params_list_954345019
pop_and_adjust_stack_shrink_stack_954345019:
mov rsi, 0
mov rdi, 0
mov rcx,0
mov rbx, 0
mov rdi, [rbp + 8]
mov rcx, [rbp + 8*2]
mov rsi, [rbp + 8*3]
add rsp, 32
mov rbx, 0
lea rbx, [rsi*8]
add rsp, rbx
push qword r12
mov r12, 0
mov r12, 0
dec r12
mov rbx, 0
shrink_push_non_optional_params_loop_954345019:
cmp rbx, r12
jbe end_shrink_push_non_optional_params_loop_954345019
push qword [r9 + 8*r12]
dec r12
jmp shrink_push_non_optional_params_loop_954345019
end_shrink_push_non_optional_params_loop_954345019:
mov r15, 0
dec r15
cmp r15, r12
je dont_push_954345019
push qword [r9 + 8*r12]
dont_push_954345019:
mov rsi, 0
mov rsi, 0
inc rsi
push rsi
push rcx
push rdi
jmp body_of_opt_954345019
enlarge_stack_954345019:
mov rsi, 0
mov rdi, 0
mov rcx,0
mov rbx, 0
mov rdx, 0
mov rdx, qword [rbp + 8*3]
mov rdi, [rbp + 8]
mov rcx, [rbp + 8*2]
mov rsi, [rbp + 8*3]
add rsp, 32
lea rbx, [rsi*8]
add rsp, rbx
push SOB_NIL_ADDRESS
mov r10, 0
mov r11, 0
mov r10, rsi
dec r10
mov rbx, 0
enlarge_push_non_optional_params_loop_954345019:
cmp rbx, r10
jb end_enlarge_push_non_optional_params_loop_954345019
push qword [r9 + 8*r10]
dec r10
jmp enlarge_push_non_optional_params_loop_954345019
end_enlarge_push_non_optional_params_loop_954345019:
mov rsi, rdx
inc rsi
push rsi
push rcx
push rdi
body_of_opt_954345019:
push rbp
mov rbp, rsp

push SOB_NIL_ADDRESS

mov qword rax, [rbp + 32]

push rax

mov rax, const_tbl+32

push rax

mov rax, qword [rbp + 16]
mov rax, qword [rax + 0]
mov rax, qword [rax + 8]

push rax

push 3
mov rax, qword [rbp + 16]
mov rax, qword [rax + 0]
mov rax, qword [rax + 0]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_358483680:

leave
ret
Lcont_954345019:


leave
ret
Lcont_795791525:


push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_946550165:

mov [fvar_tbl + 8*18], rax
mov rax, SOB_VOID_ADDRESS
	call write_sob_if_not_void


push SOB_NIL_ADDRESS

mov rax, qword [fvar_tbl + 8*4]

push rax

mov rax, qword [fvar_tbl + 8*17]

push rax

mov rax, qword [fvar_tbl + 8*19]

push rax

mov rax, qword [fvar_tbl + 8*28]

push rax

push 4
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode_222968330)
jmp Lcont_222968330
Lcode_222968330:
push rbp
mov rbp, rsp

mov rsi, [rbp + 8 * 3]			;; (*rsi holds the number of parametres on the stack*)
inc rsi
lea rsi, [rsi * 8]
MALLOC rdx, rsi			;; (*now rdx points to the allocated memory for the new vector*)
mov rcx, [rbp + 8 * 3]
mov rdi, 0			;;(*rdi will be used to point to the next address in the vector*)

mov r9, 4
;; (*start of loop to copy parameters to the new allocated vector*)
copy_params_loop_369777082:
cmp rdi, rcx
je after_params_copy_369777082
mov rsi, [rbp + 8 * r9]			;;(*now rsi points to the next parameter on the stack*)
mov [rdx + 8*rdi], rsi			;;(*copying the parameter to the new allocated vector*)
inc rdi
inc r9
jmp copy_params_loop_369777082
;; (*now rdx points to the new vector to be added to ext_env*)
;; (*mov 0 to all neccessary registers*)
after_params_copy_369777082:
mov qword [rdx + 8*rdi], SOB_NIL_ADDRESS
mov rcx, 0
mov rdi, 0
mov rsi, 0
;; (*now we need to create ext_env by copying env and adding the new vector*)
MALLOC rbx, 16			;;(*rbx points to a new allocated space for ext_env*)
mov [rbx], rdx			;;(*copying the new vector to ext_env[0]*)
mov rsi, [rbp + 8 * 2]			;;(*rsi points to current env*)
mov rcx, 1			;;(*rcx is the loop counter*)
mov r9, 0			;;(*r9 will be used to point to the next vector in current env to be copied*)
mov rdi, 1			;;(*rdi will be used to point to the next address in ext_env*)
mov r8, 0
;; (*start of loop for copying env[i] to ext_env[i+1]*)
copy_env_loop_369777082:
cmp r9, rcx
je after_env_copy_369777082
mov r8, [rsi + 8 * r9]			;;(*r8 points to the next vector int current env to be copied*) 
mov [rbx + 8 * rdi], r8			;;(*copying the pointer to the vector from env to ext_env*)
inc r9
inc rdi
jmp copy_env_loop_369777082
after_env_copy_369777082:

MAKE_CLOSURE(rax, rbx, Lcode_369777082)
jmp Lcont_369777082
Lcode_369777082:
push rbp
mov rbp, rsp
mov rdi, 1
mov rsi, qword [rbp + 8*3]
cmp qword rdi, rsi
jb vector_size_is_total_num_of_params_369777082
mov rsi, 0
mov rsi, 1
jmp create_vector_369777082
vector_size_is_total_num_of_params_369777082:
mov rsi, [rbp + 8*3]
create_vector_369777082:
lea rsi, [rsi*8]
mov r9, 0
mov rbx, 0
mov rdx, 0
MALLOC r9, rsi
mov rsi, 0
mov rsi, 1
mov rcx, 0
copy_non_opt_params_list_for_opt_369777082:
cmp rcx, rsi
je end_copy_non_opt_params_list_for_opt_369777082
mov rbx, qword PVAR(rcx)
mov qword [r9 + 8 * rcx], rbx
inc rcx
jmp copy_non_opt_params_list_for_opt_369777082
end_copy_non_opt_params_list_for_opt_369777082:
mov rsi, [rbp + 8*3]
cmp rsi, 1
je enlarge_stack_369777082
shrink_stack_369777082:
mov rdi, 1
dec rsi
mov r12, 0
mov r11, 0
mov r10, 0
mov r11, PVAR(rsi)
dec rsi
MAKE_PAIR(r12, r11, SOB_NIL_ADDRESS)
dec rdi
create_opt_params_list_369777082:
cmp rdi, rsi
je pop_and_adjust_stack_shrink_stack_369777082
mov r11, qword PVAR(rsi)
mov r10, r12
MAKE_PAIR(r12, r11, r10)
dec rsi
jmp create_opt_params_list_369777082
pop_and_adjust_stack_shrink_stack_369777082:
mov rsi, 0
mov rdi, 0
mov rcx,0
mov rbx, 0
mov rdi, [rbp + 8]
mov rcx, [rbp + 8*2]
mov rsi, [rbp + 8*3]
add rsp, 32
mov rbx, 0
lea rbx, [rsi*8]
add rsp, rbx
push qword r12
mov r12, 0
mov r12, 1
dec r12
mov rbx, 0
shrink_push_non_optional_params_loop_369777082:
cmp rbx, r12
jbe end_shrink_push_non_optional_params_loop_369777082
push qword [r9 + 8*r12]
dec r12
jmp shrink_push_non_optional_params_loop_369777082
end_shrink_push_non_optional_params_loop_369777082:
mov r15, 0
dec r15
cmp r15, r12
je dont_push_369777082
push qword [r9 + 8*r12]
dont_push_369777082:
mov rsi, 0
mov rsi, 1
inc rsi
push rsi
push rcx
push rdi
jmp body_of_opt_369777082
enlarge_stack_369777082:
mov rsi, 0
mov rdi, 0
mov rcx,0
mov rbx, 0
mov rdx, 0
mov rdx, qword [rbp + 8*3]
mov rdi, [rbp + 8]
mov rcx, [rbp + 8*2]
mov rsi, [rbp + 8*3]
add rsp, 32
lea rbx, [rsi*8]
add rsp, rbx
push SOB_NIL_ADDRESS
mov r10, 0
mov r11, 0
mov r10, rsi
dec r10
mov rbx, 0
enlarge_push_non_optional_params_loop_369777082:
cmp rbx, r10
jb end_enlarge_push_non_optional_params_loop_369777082
push qword [r9 + 8*r10]
dec r10
jmp enlarge_push_non_optional_params_loop_369777082
end_enlarge_push_non_optional_params_loop_369777082:
mov rsi, rdx
inc rsi
push rsi
push rcx
push rdi
body_of_opt_369777082:
push rbp
mov rbp, rsp

push SOB_NIL_ADDRESS

mov qword rax, [rbp + 40]

push rax

push 1
mov rax, qword [rbp + 16]
mov rax, qword [rax + 0]
mov rax, qword [rax + 24]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_425882962:

cmp rax, SOB_FALSE_ADDRESS
je Lelse_704528317

push SOB_NIL_ADDRESS

mov qword rax, [rbp + 32]

push rax

mov rax, const_tbl+41

push rax

push 2
mov rax, qword [rbp + 16]
mov rax, qword [rax + 0]
mov rax, qword [rax + 8]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_491303945:

jmp Lexit_925883755
Lelse_704528317:

push SOB_NIL_ADDRESS


push SOB_NIL_ADDRESS

mov qword rax, [rbp + 40]

push rax

mov rax, qword [rbp + 16]
mov rax, qword [rax + 0]
mov rax, qword [rax + 16]

push rax

push 2
mov rax, qword [rbp + 16]
mov rax, qword [rax + 0]
mov rax, qword [rax + 0]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_885606344:

push rax

mov qword rax, [rbp + 32]

push rax

push 2
mov rax, qword [rbp + 16]
mov rax, qword [rax + 0]
mov rax, qword [rax + 8]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_988084389:

Lexit_925883755:

leave
ret
Lcont_369777082:


leave
ret
Lcont_222968330:


push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_399233363:

mov [fvar_tbl + 8*19], rax
mov rax, SOB_VOID_ADDRESS
	call write_sob_if_not_void


push SOB_NIL_ADDRESS

mov rax, qword [fvar_tbl + 8*4]

push rax

mov rax, qword [fvar_tbl + 8*18]

push rax

mov rax, qword [fvar_tbl + 8*20]

push rax

mov rax, qword [fvar_tbl + 8*28]

push rax

push 4
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode_45872671)
jmp Lcont_45872671
Lcode_45872671:
push rbp
mov rbp, rsp

mov rsi, [rbp + 8 * 3]			;; (*rsi holds the number of parametres on the stack*)
inc rsi
lea rsi, [rsi * 8]
MALLOC rdx, rsi			;; (*now rdx points to the allocated memory for the new vector*)
mov rcx, [rbp + 8 * 3]
mov rdi, 0			;;(*rdi will be used to point to the next address in the vector*)

mov r9, 4
;; (*start of loop to copy parameters to the new allocated vector*)
copy_params_loop_114123571:
cmp rdi, rcx
je after_params_copy_114123571
mov rsi, [rbp + 8 * r9]			;;(*now rsi points to the next parameter on the stack*)
mov [rdx + 8*rdi], rsi			;;(*copying the parameter to the new allocated vector*)
inc rdi
inc r9
jmp copy_params_loop_114123571
;; (*now rdx points to the new vector to be added to ext_env*)
;; (*mov 0 to all neccessary registers*)
after_params_copy_114123571:
mov qword [rdx + 8*rdi], SOB_NIL_ADDRESS
mov rcx, 0
mov rdi, 0
mov rsi, 0
;; (*now we need to create ext_env by copying env and adding the new vector*)
MALLOC rbx, 16			;;(*rbx points to a new allocated space for ext_env*)
mov [rbx], rdx			;;(*copying the new vector to ext_env[0]*)
mov rsi, [rbp + 8 * 2]			;;(*rsi points to current env*)
mov rcx, 1			;;(*rcx is the loop counter*)
mov r9, 0			;;(*r9 will be used to point to the next vector in current env to be copied*)
mov rdi, 1			;;(*rdi will be used to point to the next address in ext_env*)
mov r8, 0
;; (*start of loop for copying env[i] to ext_env[i+1]*)
copy_env_loop_114123571:
cmp r9, rcx
je after_env_copy_114123571
mov r8, [rsi + 8 * r9]			;;(*r8 points to the next vector int current env to be copied*) 
mov [rbx + 8 * rdi], r8			;;(*copying the pointer to the vector from env to ext_env*)
inc r9
inc rdi
jmp copy_env_loop_114123571
after_env_copy_114123571:

MAKE_CLOSURE(rax, rbx, Lcode_114123571)
jmp Lcont_114123571
Lcode_114123571:
push rbp
mov rbp, rsp
mov rdi, 1
mov rsi, qword [rbp + 8*3]
cmp qword rdi, rsi
jb vector_size_is_total_num_of_params_114123571
mov rsi, 0
mov rsi, 1
jmp create_vector_114123571
vector_size_is_total_num_of_params_114123571:
mov rsi, [rbp + 8*3]
create_vector_114123571:
lea rsi, [rsi*8]
mov r9, 0
mov rbx, 0
mov rdx, 0
MALLOC r9, rsi
mov rsi, 0
mov rsi, 1
mov rcx, 0
copy_non_opt_params_list_for_opt_114123571:
cmp rcx, rsi
je end_copy_non_opt_params_list_for_opt_114123571
mov rbx, qword PVAR(rcx)
mov qword [r9 + 8 * rcx], rbx
inc rcx
jmp copy_non_opt_params_list_for_opt_114123571
end_copy_non_opt_params_list_for_opt_114123571:
mov rsi, [rbp + 8*3]
cmp rsi, 1
je enlarge_stack_114123571
shrink_stack_114123571:
mov rdi, 1
dec rsi
mov r12, 0
mov r11, 0
mov r10, 0
mov r11, PVAR(rsi)
dec rsi
MAKE_PAIR(r12, r11, SOB_NIL_ADDRESS)
dec rdi
create_opt_params_list_114123571:
cmp rdi, rsi
je pop_and_adjust_stack_shrink_stack_114123571
mov r11, qword PVAR(rsi)
mov r10, r12
MAKE_PAIR(r12, r11, r10)
dec rsi
jmp create_opt_params_list_114123571
pop_and_adjust_stack_shrink_stack_114123571:
mov rsi, 0
mov rdi, 0
mov rcx,0
mov rbx, 0
mov rdi, [rbp + 8]
mov rcx, [rbp + 8*2]
mov rsi, [rbp + 8*3]
add rsp, 32
mov rbx, 0
lea rbx, [rsi*8]
add rsp, rbx
push qword r12
mov r12, 0
mov r12, 1
dec r12
mov rbx, 0
shrink_push_non_optional_params_loop_114123571:
cmp rbx, r12
jbe end_shrink_push_non_optional_params_loop_114123571
push qword [r9 + 8*r12]
dec r12
jmp shrink_push_non_optional_params_loop_114123571
end_shrink_push_non_optional_params_loop_114123571:
mov r15, 0
dec r15
cmp r15, r12
je dont_push_114123571
push qword [r9 + 8*r12]
dont_push_114123571:
mov rsi, 0
mov rsi, 1
inc rsi
push rsi
push rcx
push rdi
jmp body_of_opt_114123571
enlarge_stack_114123571:
mov rsi, 0
mov rdi, 0
mov rcx,0
mov rbx, 0
mov rdx, 0
mov rdx, qword [rbp + 8*3]
mov rdi, [rbp + 8]
mov rcx, [rbp + 8*2]
mov rsi, [rbp + 8*3]
add rsp, 32
lea rbx, [rsi*8]
add rsp, rbx
push SOB_NIL_ADDRESS
mov r10, 0
mov r11, 0
mov r10, rsi
dec r10
mov rbx, 0
enlarge_push_non_optional_params_loop_114123571:
cmp rbx, r10
jb end_enlarge_push_non_optional_params_loop_114123571
push qword [r9 + 8*r10]
dec r10
jmp enlarge_push_non_optional_params_loop_114123571
end_enlarge_push_non_optional_params_loop_114123571:
mov rsi, rdx
inc rsi
push rsi
push rcx
push rdi
body_of_opt_114123571:
push rbp
mov rbp, rsp

push SOB_NIL_ADDRESS

mov qword rax, [rbp + 40]

push rax

push 1
mov rax, qword [rbp + 16]
mov rax, qword [rax + 0]
mov rax, qword [rax + 24]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_854160036:

cmp rax, SOB_FALSE_ADDRESS
je Lelse_742945834

push SOB_NIL_ADDRESS

mov qword rax, [rbp + 32]

push rax

mov rax, const_tbl+32

push rax

push 2
mov rax, qword [rbp + 16]
mov rax, qword [rax + 0]
mov rax, qword [rax + 8]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_565526397:

jmp Lexit_325241101
Lelse_742945834:

push SOB_NIL_ADDRESS


push SOB_NIL_ADDRESS

mov qword rax, [rbp + 40]

push rax

mov rax, qword [rbp + 16]
mov rax, qword [rax + 0]
mov rax, qword [rax + 16]

push rax

push 2
mov rax, qword [rbp + 16]
mov rax, qword [rax + 0]
mov rax, qword [rax + 0]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_403884646:

push rax

mov qword rax, [rbp + 32]

push rax

push 2
mov rax, qword [rbp + 16]
mov rax, qword [rax + 0]
mov rax, qword [rax + 8]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_380853348:

Lexit_325241101:

leave
ret
Lcont_114123571:


leave
ret
Lcont_45872671:


push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_469797467:

mov [fvar_tbl + 8*20], rax
mov rax, SOB_VOID_ADDRESS
	call write_sob_if_not_void


push SOB_NIL_ADDRESS

mov rax, qword [fvar_tbl + 8*28]

push rax

mov rax, qword [fvar_tbl + 8*24]

push rax

mov rax, qword [fvar_tbl + 8*23]

push rax

mov rax, qword [fvar_tbl + 8*4]

push rax

mov rax, qword [fvar_tbl + 8*22]

push rax

push 5
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode_264763085)
jmp Lcont_264763085
Lcode_264763085:
push rbp
mov rbp, rsp

push SOB_NIL_ADDRESS

mov rax, const_tbl+23

push rax

push 1

mov rsi, [rbp + 8 * 3]			;; (*rsi holds the number of parametres on the stack*)
inc rsi
lea rsi, [rsi * 8]
MALLOC rdx, rsi			;; (*now rdx points to the allocated memory for the new vector*)
mov rcx, [rbp + 8 * 3]
mov rdi, 0			;;(*rdi will be used to point to the next address in the vector*)

mov r9, 4
;; (*start of loop to copy parameters to the new allocated vector*)
copy_params_loop_182772876:
cmp rdi, rcx
je after_params_copy_182772876
mov rsi, [rbp + 8 * r9]			;;(*now rsi points to the next parameter on the stack*)
mov [rdx + 8*rdi], rsi			;;(*copying the parameter to the new allocated vector*)
inc rdi
inc r9
jmp copy_params_loop_182772876
;; (*now rdx points to the new vector to be added to ext_env*)
;; (*mov 0 to all neccessary registers*)
after_params_copy_182772876:
mov qword [rdx + 8*rdi], SOB_NIL_ADDRESS
mov rcx, 0
mov rdi, 0
mov rsi, 0
;; (*now we need to create ext_env by copying env and adding the new vector*)
MALLOC rbx, 16			;;(*rbx points to a new allocated space for ext_env*)
mov [rbx], rdx			;;(*coping the new vector to ext_env[0]*)
mov rsi, [rbp + 8 * 2]			;;(*rsi points to current env*)
mov rcx, 1			;;(*rcx is the loop counter*)
mov r9, 0			;;(*r9 will be used to point to the next vector in current env to be copied*)
mov rdi, 1			;;(*rdi will be used to point to the next address in ext_env*)
mov r8, 0
;; (*start of loop for copying env[i] to ext_env[i+1]*)
copy_env_loop_182772876:
cmp r9, rcx
je after_env_copy_182772876
mov r8, [rsi + 8 * r9]			;;(*r8 points to the next vector int current env to be copied*) 
mov [rbx + 8 * rdi], r8			;;(*copying the pointer to the vector from env to ext_env*)
inc r9
inc rdi
jmp copy_env_loop_182772876
after_env_copy_182772876:

MAKE_CLOSURE(rax, rbx, Lcode_182772876)
jmp Lcont_182772876
Lcode_182772876:
push rbp
mov rbp, rsp

mov qword rax, [rbp + 32]
MALLOC r11, 8
mov qword [r11], rax
mov rax, r11

mov qword [rbp + 32], rax
mov rax, SOB_VOID_ADDRESS




mov rsi, [rbp + 8 * 3]			;; (*rsi holds the number of parametres on the stack*)
inc rsi
lea rsi, [rsi * 8]
MALLOC rdx, rsi			;; (*now rdx points to the allocated memory for the new vector*)
mov rcx, [rbp + 8 * 3]
mov rdi, 0			;;(*rdi will be used to point to the next address in the vector*)

mov r9, 4
;; (*start of loop to copy parameters to the new allocated vector*)
copy_params_loop_650329590:
cmp rdi, rcx
je after_params_copy_650329590
mov rsi, [rbp + 8 * r9]			;;(*now rsi points to the next parameter on the stack*)
mov [rdx + 8*rdi], rsi			;;(*copying the parameter to the new allocated vector*)
inc rdi
inc r9
jmp copy_params_loop_650329590
;; (*now rdx points to the new vector to be added to ext_env*)
;; (*mov 0 to all neccessary registers*)
after_params_copy_650329590:
mov qword [rdx + 8*rdi], SOB_NIL_ADDRESS
mov rcx, 0
mov rdi, 0
mov rsi, 0
;; (*now we need to create ext_env by copying env and adding the new vector*)
MALLOC rbx, 24			;;(*rbx points to a new allocated space for ext_env*)
mov [rbx], rdx			;;(*copying the new vector to ext_env[0]*)
mov rsi, [rbp + 8 * 2]			;;(*rsi points to current env*)
mov rcx, 2			;;(*rcx is the loop counter*)
mov r9, 0			;;(*r9 will be used to point to the next vector in current env to be copied*)
mov rdi, 1			;;(*rdi will be used to point to the next address in ext_env*)
mov r8, 0
;; (*start of loop for copying env[i] to ext_env[i+1]*)
copy_env_loop_650329590:
cmp r9, rcx
je after_env_copy_650329590
mov r8, [rsi + 8 * r9]			;;(*r8 points to the next vector int current env to be copied*) 
mov [rbx + 8 * rdi], r8			;;(*copying the pointer to the vector from env to ext_env*)
inc r9
inc rdi
jmp copy_env_loop_650329590
after_env_copy_650329590:

MAKE_CLOSURE(rax, rbx, Lcode_650329590)
jmp Lcont_650329590
Lcode_650329590:
push rbp
mov rbp, rsp
mov rdi, 1
mov rsi, qword [rbp + 8*3]
cmp qword rdi, rsi
jb vector_size_is_total_num_of_params_650329590
mov rsi, 0
mov rsi, 1
jmp create_vector_650329590
vector_size_is_total_num_of_params_650329590:
mov rsi, [rbp + 8*3]
create_vector_650329590:
lea rsi, [rsi*8]
mov r9, 0
mov rbx, 0
mov rdx, 0
MALLOC r9, rsi
mov rsi, 0
mov rsi, 1
mov rcx, 0
copy_non_opt_params_list_for_opt_650329590:
cmp rcx, rsi
je end_copy_non_opt_params_list_for_opt_650329590
mov rbx, qword PVAR(rcx)
mov qword [r9 + 8 * rcx], rbx
inc rcx
jmp copy_non_opt_params_list_for_opt_650329590
end_copy_non_opt_params_list_for_opt_650329590:
mov rsi, [rbp + 8*3]
cmp rsi, 1
je enlarge_stack_650329590
shrink_stack_650329590:
mov rdi, 1
dec rsi
mov r12, 0
mov r11, 0
mov r10, 0
mov r11, PVAR(rsi)
dec rsi
MAKE_PAIR(r12, r11, SOB_NIL_ADDRESS)
dec rdi
create_opt_params_list_650329590:
cmp rdi, rsi
je pop_and_adjust_stack_shrink_stack_650329590
mov r11, qword PVAR(rsi)
mov r10, r12
MAKE_PAIR(r12, r11, r10)
dec rsi
jmp create_opt_params_list_650329590
pop_and_adjust_stack_shrink_stack_650329590:
mov rsi, 0
mov rdi, 0
mov rcx,0
mov rbx, 0
mov rdi, [rbp + 8]
mov rcx, [rbp + 8*2]
mov rsi, [rbp + 8*3]
add rsp, 32
mov rbx, 0
lea rbx, [rsi*8]
add rsp, rbx
push qword r12
mov r12, 0
mov r12, 1
dec r12
mov rbx, 0
shrink_push_non_optional_params_loop_650329590:
cmp rbx, r12
jbe end_shrink_push_non_optional_params_loop_650329590
push qword [r9 + 8*r12]
dec r12
jmp shrink_push_non_optional_params_loop_650329590
end_shrink_push_non_optional_params_loop_650329590:
mov r15, 0
dec r15
cmp r15, r12
je dont_push_650329590
push qword [r9 + 8*r12]
dont_push_650329590:
mov rsi, 0
mov rsi, 1
inc rsi
push rsi
push rcx
push rdi
jmp body_of_opt_650329590
enlarge_stack_650329590:
mov rsi, 0
mov rdi, 0
mov rcx,0
mov rbx, 0
mov rdx, 0
mov rdx, qword [rbp + 8*3]
mov rdi, [rbp + 8]
mov rcx, [rbp + 8*2]
mov rsi, [rbp + 8*3]
add rsp, 32
lea rbx, [rsi*8]
add rsp, rbx
push SOB_NIL_ADDRESS
mov r10, 0
mov r11, 0
mov r10, rsi
dec r10
mov rbx, 0
enlarge_push_non_optional_params_loop_650329590:
cmp rbx, r10
jb end_enlarge_push_non_optional_params_loop_650329590
push qword [r9 + 8*r10]
dec r10
jmp enlarge_push_non_optional_params_loop_650329590
end_enlarge_push_non_optional_params_loop_650329590:
mov rsi, rdx
inc rsi
push rsi
push rcx
push rdi
body_of_opt_650329590:
push rbp
mov rbp, rsp

push SOB_NIL_ADDRESS

mov qword rax, [rbp + 40]

push rax

push 1
mov rax, qword [rbp + 16]
mov rax, qword [rax + 8]
mov rax, qword [rax + 8]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_361404286:

cmp rax, SOB_FALSE_ADDRESS
je Lelse_139596420
mov rax, const_tbl+4

jmp Lexit_802660656
Lelse_139596420:

push SOB_NIL_ADDRESS


push SOB_NIL_ADDRESS

mov qword rax, [rbp + 40]

push rax

push 1
mov rax, qword [rbp + 16]
mov rax, qword [rax + 8]
mov rax, qword [rax + 16]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_986630149:

push rax

mov qword rax, [rbp + 32]

push rax

push 2
mov rax, qword [rbp + 16]
mov rax, qword [rax + 8]
mov rax, qword [rax + 0]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_23684769:

cmp rax, SOB_FALSE_ADDRESS
je Lelse_124999081

push SOB_NIL_ADDRESS


push SOB_NIL_ADDRESS

mov qword rax, [rbp + 40]

push rax

push 1
mov rax, qword [rbp + 16]
mov rax, qword [rax + 8]
mov rax, qword [rax + 24]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_47888016:

push rax

mov qword rax, [rbp + 32]

push rax

mov rax, qword [rbp + 16]
mov rax, qword [rax + 0]
mov rax, qword [rax + 0]

mov rax, qword [rax]

push rax

push 3
mov rax, qword [rbp + 16]
mov rax, qword [rax + 8]
mov rax, qword [rax + 32]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_613964162:

jmp Lexit_148094636
Lelse_124999081:
mov rax, const_tbl+2

Lexit_148094636:

Lexit_802660656:

leave
ret
Lcont_650329590:


push rax
mov qword rax, [rbp + 32]

pop qword [rax]
mov rax, SOB_VOID_ADDRESS


mov qword rax, [rbp + 32]

mov rax, qword [rax]



leave
ret
Lcont_182772876:


push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_810501363:

leave
ret
Lcont_264763085:


push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_465023326:

mov [fvar_tbl + 8*22], rax
mov rax, SOB_VOID_ADDRESS
	call write_sob_if_not_void


push SOB_NIL_ADDRESS

mov rax, qword [fvar_tbl + 8*24]

push rax

mov rax, qword [fvar_tbl + 8*23]

push rax

mov rax, qword [fvar_tbl + 8*21]

push rax

mov rax, qword [fvar_tbl + 8*4]

push rax

push 4
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode_578098865)
jmp Lcont_578098865
Lcode_578098865:
push rbp
mov rbp, rsp

push SOB_NIL_ADDRESS

mov rax, const_tbl+23

push rax

push 1

mov rsi, [rbp + 8 * 3]			;; (*rsi holds the number of parametres on the stack*)
inc rsi
lea rsi, [rsi * 8]
MALLOC rdx, rsi			;; (*now rdx points to the allocated memory for the new vector*)
mov rcx, [rbp + 8 * 3]
mov rdi, 0			;;(*rdi will be used to point to the next address in the vector*)

mov r9, 4
;; (*start of loop to copy parameters to the new allocated vector*)
copy_params_loop_384027154:
cmp rdi, rcx
je after_params_copy_384027154
mov rsi, [rbp + 8 * r9]			;;(*now rsi points to the next parameter on the stack*)
mov [rdx + 8*rdi], rsi			;;(*copying the parameter to the new allocated vector*)
inc rdi
inc r9
jmp copy_params_loop_384027154
;; (*now rdx points to the new vector to be added to ext_env*)
;; (*mov 0 to all neccessary registers*)
after_params_copy_384027154:
mov qword [rdx + 8*rdi], SOB_NIL_ADDRESS
mov rcx, 0
mov rdi, 0
mov rsi, 0
;; (*now we need to create ext_env by copying env and adding the new vector*)
MALLOC rbx, 16			;;(*rbx points to a new allocated space for ext_env*)
mov [rbx], rdx			;;(*coping the new vector to ext_env[0]*)
mov rsi, [rbp + 8 * 2]			;;(*rsi points to current env*)
mov rcx, 1			;;(*rcx is the loop counter*)
mov r9, 0			;;(*r9 will be used to point to the next vector in current env to be copied*)
mov rdi, 1			;;(*rdi will be used to point to the next address in ext_env*)
mov r8, 0
;; (*start of loop for copying env[i] to ext_env[i+1]*)
copy_env_loop_384027154:
cmp r9, rcx
je after_env_copy_384027154
mov r8, [rsi + 8 * r9]			;;(*r8 points to the next vector int current env to be copied*) 
mov [rbx + 8 * rdi], r8			;;(*copying the pointer to the vector from env to ext_env*)
inc r9
inc rdi
jmp copy_env_loop_384027154
after_env_copy_384027154:

MAKE_CLOSURE(rax, rbx, Lcode_384027154)
jmp Lcont_384027154
Lcode_384027154:
push rbp
mov rbp, rsp

mov qword rax, [rbp + 32]
MALLOC r11, 8
mov qword [r11], rax
mov rax, r11

mov qword [rbp + 32], rax
mov rax, SOB_VOID_ADDRESS




mov rsi, [rbp + 8 * 3]			;; (*rsi holds the number of parametres on the stack*)
inc rsi
lea rsi, [rsi * 8]
MALLOC rdx, rsi			;; (*now rdx points to the allocated memory for the new vector*)
mov rcx, [rbp + 8 * 3]
mov rdi, 0			;;(*rdi will be used to point to the next address in the vector*)

mov r9, 4
;; (*start of loop to copy parameters to the new allocated vector*)
copy_params_loop_116195277:
cmp rdi, rcx
je after_params_copy_116195277
mov rsi, [rbp + 8 * r9]			;;(*now rsi points to the next parameter on the stack*)
mov [rdx + 8*rdi], rsi			;;(*copying the parameter to the new allocated vector*)
inc rdi
inc r9
jmp copy_params_loop_116195277
;; (*now rdx points to the new vector to be added to ext_env*)
;; (*mov 0 to all neccessary registers*)
after_params_copy_116195277:
mov qword [rdx + 8*rdi], SOB_NIL_ADDRESS
mov rcx, 0
mov rdi, 0
mov rsi, 0
;; (*now we need to create ext_env by copying env and adding the new vector*)
MALLOC rbx, 24			;;(*rbx points to a new allocated space for ext_env*)
mov [rbx], rdx			;;(*coping the new vector to ext_env[0]*)
mov rsi, [rbp + 8 * 2]			;;(*rsi points to current env*)
mov rcx, 2			;;(*rcx is the loop counter*)
mov r9, 0			;;(*r9 will be used to point to the next vector in current env to be copied*)
mov rdi, 1			;;(*rdi will be used to point to the next address in ext_env*)
mov r8, 0
;; (*start of loop for copying env[i] to ext_env[i+1]*)
copy_env_loop_116195277:
cmp r9, rcx
je after_env_copy_116195277
mov r8, [rsi + 8 * r9]			;;(*r8 points to the next vector int current env to be copied*) 
mov [rbx + 8 * rdi], r8			;;(*copying the pointer to the vector from env to ext_env*)
inc r9
inc rdi
jmp copy_env_loop_116195277
after_env_copy_116195277:

MAKE_CLOSURE(rax, rbx, Lcode_116195277)
jmp Lcont_116195277
Lcode_116195277:
push rbp
mov rbp, rsp

push SOB_NIL_ADDRESS

mov qword rax, [rbp + 40]

push rax

push 1
mov rax, qword [rbp + 16]
mov rax, qword [rax + 8]
mov rax, qword [rax + 0]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_421021563:

cmp rax, SOB_FALSE_ADDRESS
je Lelse_483417528
mov rax, const_tbl+4

jmp Lexit_514260817
Lelse_483417528:

push SOB_NIL_ADDRESS


push SOB_NIL_ADDRESS

mov qword rax, [rbp + 40]

push rax

push 1
mov rax, qword [rbp + 16]
mov rax, qword [rax + 8]
mov rax, qword [rax + 16]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_256182561:

push rax

mov qword rax, [rbp + 32]

push rax

push 2
mov rax, qword [rbp + 16]
mov rax, qword [rax + 8]
mov rax, qword [rax + 8]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_303242831:

cmp rax, SOB_FALSE_ADDRESS
je Lelse_514664874

push SOB_NIL_ADDRESS


push SOB_NIL_ADDRESS

mov qword rax, [rbp + 40]

push rax

push 1
mov rax, qword [rbp + 16]
mov rax, qword [rax + 8]
mov rax, qword [rax + 24]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_777214754:

push rax


push SOB_NIL_ADDRESS

mov qword rax, [rbp + 40]

push rax

push 1
mov rax, qword [rbp + 16]
mov rax, qword [rax + 8]
mov rax, qword [rax + 16]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_226304471:

push rax

push 2
mov rax, qword [rbp + 16]
mov rax, qword [rax + 0]
mov rax, qword [rax + 0]

mov rax, qword [rax]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_991360546:

jmp Lexit_736646258
Lelse_514664874:
mov rax, const_tbl+2

Lexit_736646258:

Lexit_514260817:

leave
ret
Lcont_116195277:


push rax
mov qword rax, [rbp + 32]

pop qword [rax]
mov rax, SOB_VOID_ADDRESS



mov rsi, [rbp + 8 * 3]			;; (*rsi holds the number of parametres on the stack*)
inc rsi
lea rsi, [rsi * 8]
MALLOC rdx, rsi			;; (*now rdx points to the allocated memory for the new vector*)
mov rcx, [rbp + 8 * 3]
mov rdi, 0			;;(*rdi will be used to point to the next address in the vector*)

mov r9, 4
;; (*start of loop to copy parameters to the new allocated vector*)
copy_params_loop_967574633:
cmp rdi, rcx
je after_params_copy_967574633
mov rsi, [rbp + 8 * r9]			;;(*now rsi points to the next parameter on the stack*)
mov [rdx + 8*rdi], rsi			;;(*copying the parameter to the new allocated vector*)
inc rdi
inc r9
jmp copy_params_loop_967574633
;; (*now rdx points to the new vector to be added to ext_env*)
;; (*mov 0 to all neccessary registers*)
after_params_copy_967574633:
mov qword [rdx + 8*rdi], SOB_NIL_ADDRESS
mov rcx, 0
mov rdi, 0
mov rsi, 0
;; (*now we need to create ext_env by copying env and adding the new vector*)
MALLOC rbx, 24			;;(*rbx points to a new allocated space for ext_env*)
mov [rbx], rdx			;;(*copying the new vector to ext_env[0]*)
mov rsi, [rbp + 8 * 2]			;;(*rsi points to current env*)
mov rcx, 2			;;(*rcx is the loop counter*)
mov r9, 0			;;(*r9 will be used to point to the next vector in current env to be copied*)
mov rdi, 1			;;(*rdi will be used to point to the next address in ext_env*)
mov r8, 0
;; (*start of loop for copying env[i] to ext_env[i+1]*)
copy_env_loop_967574633:
cmp r9, rcx
je after_env_copy_967574633
mov r8, [rsi + 8 * r9]			;;(*r8 points to the next vector int current env to be copied*) 
mov [rbx + 8 * rdi], r8			;;(*copying the pointer to the vector from env to ext_env*)
inc r9
inc rdi
jmp copy_env_loop_967574633
after_env_copy_967574633:

MAKE_CLOSURE(rax, rbx, Lcode_967574633)
jmp Lcont_967574633
Lcode_967574633:
push rbp
mov rbp, rsp
mov rdi, 1
mov rsi, qword [rbp + 8*3]
cmp qword rdi, rsi
jb vector_size_is_total_num_of_params_967574633
mov rsi, 0
mov rsi, 1
jmp create_vector_967574633
vector_size_is_total_num_of_params_967574633:
mov rsi, [rbp + 8*3]
create_vector_967574633:
lea rsi, [rsi*8]
mov r9, 0
mov rbx, 0
mov rdx, 0
MALLOC r9, rsi
mov rsi, 0
mov rsi, 1
mov rcx, 0
copy_non_opt_params_list_for_opt_967574633:
cmp rcx, rsi
je end_copy_non_opt_params_list_for_opt_967574633
mov rbx, qword PVAR(rcx)
mov qword [r9 + 8 * rcx], rbx
inc rcx
jmp copy_non_opt_params_list_for_opt_967574633
end_copy_non_opt_params_list_for_opt_967574633:
mov rsi, [rbp + 8*3]
cmp rsi, 1
je enlarge_stack_967574633
shrink_stack_967574633:
mov rdi, 1
dec rsi
mov r12, 0
mov r11, 0
mov r10, 0
mov r11, PVAR(rsi)
dec rsi
MAKE_PAIR(r12, r11, SOB_NIL_ADDRESS)
dec rdi
create_opt_params_list_967574633:
cmp rdi, rsi
je pop_and_adjust_stack_shrink_stack_967574633
mov r11, qword PVAR(rsi)
mov r10, r12
MAKE_PAIR(r12, r11, r10)
dec rsi
jmp create_opt_params_list_967574633
pop_and_adjust_stack_shrink_stack_967574633:
mov rsi, 0
mov rdi, 0
mov rcx,0
mov rbx, 0
mov rdi, [rbp + 8]
mov rcx, [rbp + 8*2]
mov rsi, [rbp + 8*3]
add rsp, 32
mov rbx, 0
lea rbx, [rsi*8]
add rsp, rbx
push qword r12
mov r12, 0
mov r12, 1
dec r12
mov rbx, 0
shrink_push_non_optional_params_loop_967574633:
cmp rbx, r12
jbe end_shrink_push_non_optional_params_loop_967574633
push qword [r9 + 8*r12]
dec r12
jmp shrink_push_non_optional_params_loop_967574633
end_shrink_push_non_optional_params_loop_967574633:
mov r15, 0
dec r15
cmp r15, r12
je dont_push_967574633
push qword [r9 + 8*r12]
dont_push_967574633:
mov rsi, 0
mov rsi, 1
inc rsi
push rsi
push rcx
push rdi
jmp body_of_opt_967574633
enlarge_stack_967574633:
mov rsi, 0
mov rdi, 0
mov rcx,0
mov rbx, 0
mov rdx, 0
mov rdx, qword [rbp + 8*3]
mov rdi, [rbp + 8]
mov rcx, [rbp + 8*2]
mov rsi, [rbp + 8*3]
add rsp, 32
lea rbx, [rsi*8]
add rsp, rbx
push SOB_NIL_ADDRESS
mov r10, 0
mov r11, 0
mov r10, rsi
dec r10
mov rbx, 0
enlarge_push_non_optional_params_loop_967574633:
cmp rbx, r10
jb end_enlarge_push_non_optional_params_loop_967574633
push qword [r9 + 8*r10]
dec r10
jmp enlarge_push_non_optional_params_loop_967574633
end_enlarge_push_non_optional_params_loop_967574633:
mov rsi, rdx
inc rsi
push rsi
push rcx
push rdi
body_of_opt_967574633:
push rbp
mov rbp, rsp

push SOB_NIL_ADDRESS

mov qword rax, [rbp + 40]

push rax

mov qword rax, [rbp + 32]

push rax

push 2
mov rax, qword [rbp + 16]
mov rax, qword [rax + 0]
mov rax, qword [rax + 0]

mov rax, qword [rax]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_337831655:

leave
ret
Lcont_967574633:




leave
ret
Lcont_384027154:


push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_905984946:

leave
ret
Lcont_578098865:


push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_607713823:

mov [fvar_tbl + 8*21], rax
mov rax, SOB_VOID_ADDRESS
	call write_sob_if_not_void


push SOB_NIL_ADDRESS

mov rax, qword [fvar_tbl + 8*24]

push rax

mov rax, qword [fvar_tbl + 8*23]

push rax

mov rax, qword [fvar_tbl + 8*38]

push rax

mov rax, qword [fvar_tbl + 8*22]

push rax

mov rax, qword [fvar_tbl + 8*21]

push rax

mov rax, qword [fvar_tbl + 8*4]

push rax

push 6
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode_541256566)
jmp Lcont_541256566
Lcode_541256566:
push rbp
mov rbp, rsp

push SOB_NIL_ADDRESS

mov rax, const_tbl+23

push rax

push 1

mov rsi, [rbp + 8 * 3]			;; (*rsi holds the number of parametres on the stack*)
inc rsi
lea rsi, [rsi * 8]
MALLOC rdx, rsi			;; (*now rdx points to the allocated memory for the new vector*)
mov rcx, [rbp + 8 * 3]
mov rdi, 0			;;(*rdi will be used to point to the next address in the vector*)

mov r9, 4
;; (*start of loop to copy parameters to the new allocated vector*)
copy_params_loop_538829788:
cmp rdi, rcx
je after_params_copy_538829788
mov rsi, [rbp + 8 * r9]			;;(*now rsi points to the next parameter on the stack*)
mov [rdx + 8*rdi], rsi			;;(*copying the parameter to the new allocated vector*)
inc rdi
inc r9
jmp copy_params_loop_538829788
;; (*now rdx points to the new vector to be added to ext_env*)
;; (*mov 0 to all neccessary registers*)
after_params_copy_538829788:
mov qword [rdx + 8*rdi], SOB_NIL_ADDRESS
mov rcx, 0
mov rdi, 0
mov rsi, 0
;; (*now we need to create ext_env by copying env and adding the new vector*)
MALLOC rbx, 16			;;(*rbx points to a new allocated space for ext_env*)
mov [rbx], rdx			;;(*coping the new vector to ext_env[0]*)
mov rsi, [rbp + 8 * 2]			;;(*rsi points to current env*)
mov rcx, 1			;;(*rcx is the loop counter*)
mov r9, 0			;;(*r9 will be used to point to the next vector in current env to be copied*)
mov rdi, 1			;;(*rdi will be used to point to the next address in ext_env*)
mov r8, 0
;; (*start of loop for copying env[i] to ext_env[i+1]*)
copy_env_loop_538829788:
cmp r9, rcx
je after_env_copy_538829788
mov r8, [rsi + 8 * r9]			;;(*r8 points to the next vector int current env to be copied*) 
mov [rbx + 8 * rdi], r8			;;(*copying the pointer to the vector from env to ext_env*)
inc r9
inc rdi
jmp copy_env_loop_538829788
after_env_copy_538829788:

MAKE_CLOSURE(rax, rbx, Lcode_538829788)
jmp Lcont_538829788
Lcode_538829788:
push rbp
mov rbp, rsp

mov qword rax, [rbp + 32]
MALLOC r11, 8
mov qword [r11], rax
mov rax, r11

mov qword [rbp + 32], rax
mov rax, SOB_VOID_ADDRESS




mov rsi, [rbp + 8 * 3]			;; (*rsi holds the number of parametres on the stack*)
inc rsi
lea rsi, [rsi * 8]
MALLOC rdx, rsi			;; (*now rdx points to the allocated memory for the new vector*)
mov rcx, [rbp + 8 * 3]
mov rdi, 0			;;(*rdi will be used to point to the next address in the vector*)

mov r9, 4
;; (*start of loop to copy parameters to the new allocated vector*)
copy_params_loop_151124289:
cmp rdi, rcx
je after_params_copy_151124289
mov rsi, [rbp + 8 * r9]			;;(*now rsi points to the next parameter on the stack*)
mov [rdx + 8*rdi], rsi			;;(*copying the parameter to the new allocated vector*)
inc rdi
inc r9
jmp copy_params_loop_151124289
;; (*now rdx points to the new vector to be added to ext_env*)
;; (*mov 0 to all neccessary registers*)
after_params_copy_151124289:
mov qword [rdx + 8*rdi], SOB_NIL_ADDRESS
mov rcx, 0
mov rdi, 0
mov rsi, 0
;; (*now we need to create ext_env by copying env and adding the new vector*)
MALLOC rbx, 24			;;(*rbx points to a new allocated space for ext_env*)
mov [rbx], rdx			;;(*coping the new vector to ext_env[0]*)
mov rsi, [rbp + 8 * 2]			;;(*rsi points to current env*)
mov rcx, 2			;;(*rcx is the loop counter*)
mov r9, 0			;;(*r9 will be used to point to the next vector in current env to be copied*)
mov rdi, 1			;;(*rdi will be used to point to the next address in ext_env*)
mov r8, 0
;; (*start of loop for copying env[i] to ext_env[i+1]*)
copy_env_loop_151124289:
cmp r9, rcx
je after_env_copy_151124289
mov r8, [rsi + 8 * r9]			;;(*r8 points to the next vector int current env to be copied*) 
mov [rbx + 8 * rdi], r8			;;(*copying the pointer to the vector from env to ext_env*)
inc r9
inc rdi
jmp copy_env_loop_151124289
after_env_copy_151124289:

MAKE_CLOSURE(rax, rbx, Lcode_151124289)
jmp Lcont_151124289
Lcode_151124289:
push rbp
mov rbp, rsp

push SOB_NIL_ADDRESS

mov qword rax, [rbp + 40]

push rax

push 1
mov rax, qword [rbp + 16]
mov rax, qword [rax + 8]
mov rax, qword [rax + 0]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_918145467:

cmp rax, SOB_FALSE_ADDRESS
je Lelse_98695905
mov rax, const_tbl+4

jmp Lexit_829527378
Lelse_98695905:

push SOB_NIL_ADDRESS


push SOB_NIL_ADDRESS


push SOB_NIL_ADDRESS

mov qword rax, [rbp + 40]

push rax

push 1
mov rax, qword [rbp + 16]
mov rax, qword [rax + 8]
mov rax, qword [rax + 32]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_864270887:

push rax

mov qword rax, [rbp + 32]

push rax

push 2
mov rax, qword [rbp + 16]
mov rax, qword [rax + 8]
mov rax, qword [rax + 8]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_441436369:

cmp rax, SOB_FALSE_ADDRESS
jne Lexit_653586493

push SOB_NIL_ADDRESS


push SOB_NIL_ADDRESS

mov qword rax, [rbp + 40]

push rax

push 1
mov rax, qword [rbp + 16]
mov rax, qword [rax + 8]
mov rax, qword [rax + 32]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_53231182:

push rax

mov qword rax, [rbp + 32]

push rax

push 2
mov rax, qword [rbp + 16]
mov rax, qword [rax + 8]
mov rax, qword [rax + 16]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_567875788:

Lexit_653586493:

push rax

push 1
mov rax, qword [rbp + 16]
mov rax, qword [rax + 8]
mov rax, qword [rax + 24]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_831201747:

cmp rax, SOB_FALSE_ADDRESS
je Lelse_236572

push SOB_NIL_ADDRESS


push SOB_NIL_ADDRESS

mov qword rax, [rbp + 40]

push rax

push 1
mov rax, qword [rbp + 16]
mov rax, qword [rax + 8]
mov rax, qword [rax + 40]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_514988712:

push rax


push SOB_NIL_ADDRESS

mov qword rax, [rbp + 40]

push rax

push 1
mov rax, qword [rbp + 16]
mov rax, qword [rax + 8]
mov rax, qword [rax + 32]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_338771299:

push rax

push 2
mov rax, qword [rbp + 16]
mov rax, qword [rax + 0]
mov rax, qword [rax + 0]

mov rax, qword [rax]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_933494370:

jmp Lexit_528306746
Lelse_236572:
mov rax, const_tbl+2

Lexit_528306746:

Lexit_829527378:

leave
ret
Lcont_151124289:


push rax
mov qword rax, [rbp + 32]

pop qword [rax]
mov rax, SOB_VOID_ADDRESS



mov rsi, [rbp + 8 * 3]			;; (*rsi holds the number of parametres on the stack*)
inc rsi
lea rsi, [rsi * 8]
MALLOC rdx, rsi			;; (*now rdx points to the allocated memory for the new vector*)
mov rcx, [rbp + 8 * 3]
mov rdi, 0			;;(*rdi will be used to point to the next address in the vector*)

mov r9, 4
;; (*start of loop to copy parameters to the new allocated vector*)
copy_params_loop_6449431:
cmp rdi, rcx
je after_params_copy_6449431
mov rsi, [rbp + 8 * r9]			;;(*now rsi points to the next parameter on the stack*)
mov [rdx + 8*rdi], rsi			;;(*copying the parameter to the new allocated vector*)
inc rdi
inc r9
jmp copy_params_loop_6449431
;; (*now rdx points to the new vector to be added to ext_env*)
;; (*mov 0 to all neccessary registers*)
after_params_copy_6449431:
mov qword [rdx + 8*rdi], SOB_NIL_ADDRESS
mov rcx, 0
mov rdi, 0
mov rsi, 0
;; (*now we need to create ext_env by copying env and adding the new vector*)
MALLOC rbx, 24			;;(*rbx points to a new allocated space for ext_env*)
mov [rbx], rdx			;;(*copying the new vector to ext_env[0]*)
mov rsi, [rbp + 8 * 2]			;;(*rsi points to current env*)
mov rcx, 2			;;(*rcx is the loop counter*)
mov r9, 0			;;(*r9 will be used to point to the next vector in current env to be copied*)
mov rdi, 1			;;(*rdi will be used to point to the next address in ext_env*)
mov r8, 0
;; (*start of loop for copying env[i] to ext_env[i+1]*)
copy_env_loop_6449431:
cmp r9, rcx
je after_env_copy_6449431
mov r8, [rsi + 8 * r9]			;;(*r8 points to the next vector int current env to be copied*) 
mov [rbx + 8 * rdi], r8			;;(*copying the pointer to the vector from env to ext_env*)
inc r9
inc rdi
jmp copy_env_loop_6449431
after_env_copy_6449431:

MAKE_CLOSURE(rax, rbx, Lcode_6449431)
jmp Lcont_6449431
Lcode_6449431:
push rbp
mov rbp, rsp
mov rdi, 1
mov rsi, qword [rbp + 8*3]
cmp qword rdi, rsi
jb vector_size_is_total_num_of_params_6449431
mov rsi, 0
mov rsi, 1
jmp create_vector_6449431
vector_size_is_total_num_of_params_6449431:
mov rsi, [rbp + 8*3]
create_vector_6449431:
lea rsi, [rsi*8]
mov r9, 0
mov rbx, 0
mov rdx, 0
MALLOC r9, rsi
mov rsi, 0
mov rsi, 1
mov rcx, 0
copy_non_opt_params_list_for_opt_6449431:
cmp rcx, rsi
je end_copy_non_opt_params_list_for_opt_6449431
mov rbx, qword PVAR(rcx)
mov qword [r9 + 8 * rcx], rbx
inc rcx
jmp copy_non_opt_params_list_for_opt_6449431
end_copy_non_opt_params_list_for_opt_6449431:
mov rsi, [rbp + 8*3]
cmp rsi, 1
je enlarge_stack_6449431
shrink_stack_6449431:
mov rdi, 1
dec rsi
mov r12, 0
mov r11, 0
mov r10, 0
mov r11, PVAR(rsi)
dec rsi
MAKE_PAIR(r12, r11, SOB_NIL_ADDRESS)
dec rdi
create_opt_params_list_6449431:
cmp rdi, rsi
je pop_and_adjust_stack_shrink_stack_6449431
mov r11, qword PVAR(rsi)
mov r10, r12
MAKE_PAIR(r12, r11, r10)
dec rsi
jmp create_opt_params_list_6449431
pop_and_adjust_stack_shrink_stack_6449431:
mov rsi, 0
mov rdi, 0
mov rcx,0
mov rbx, 0
mov rdi, [rbp + 8]
mov rcx, [rbp + 8*2]
mov rsi, [rbp + 8*3]
add rsp, 32
mov rbx, 0
lea rbx, [rsi*8]
add rsp, rbx
push qword r12
mov r12, 0
mov r12, 1
dec r12
mov rbx, 0
shrink_push_non_optional_params_loop_6449431:
cmp rbx, r12
jbe end_shrink_push_non_optional_params_loop_6449431
push qword [r9 + 8*r12]
dec r12
jmp shrink_push_non_optional_params_loop_6449431
end_shrink_push_non_optional_params_loop_6449431:
mov r15, 0
dec r15
cmp r15, r12
je dont_push_6449431
push qword [r9 + 8*r12]
dont_push_6449431:
mov rsi, 0
mov rsi, 1
inc rsi
push rsi
push rcx
push rdi
jmp body_of_opt_6449431
enlarge_stack_6449431:
mov rsi, 0
mov rdi, 0
mov rcx,0
mov rbx, 0
mov rdx, 0
mov rdx, qword [rbp + 8*3]
mov rdi, [rbp + 8]
mov rcx, [rbp + 8*2]
mov rsi, [rbp + 8*3]
add rsp, 32
lea rbx, [rsi*8]
add rsp, rbx
push SOB_NIL_ADDRESS
mov r10, 0
mov r11, 0
mov r10, rsi
dec r10
mov rbx, 0
enlarge_push_non_optional_params_loop_6449431:
cmp rbx, r10
jb end_enlarge_push_non_optional_params_loop_6449431
push qword [r9 + 8*r10]
dec r10
jmp enlarge_push_non_optional_params_loop_6449431
end_enlarge_push_non_optional_params_loop_6449431:
mov rsi, rdx
inc rsi
push rsi
push rcx
push rdi
body_of_opt_6449431:
push rbp
mov rbp, rsp

push SOB_NIL_ADDRESS

mov qword rax, [rbp + 40]

push rax

mov qword rax, [rbp + 32]

push rax

push 2
mov rax, qword [rbp + 16]
mov rax, qword [rax + 0]
mov rax, qword [rax + 0]

mov rax, qword [rax]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_517064495:

leave
ret
Lcont_6449431:




leave
ret
Lcont_538829788:


push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_621109403:

leave
ret
Lcont_541256566:


push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_691104538:

mov [fvar_tbl + 8*40], rax
mov rax, SOB_VOID_ADDRESS
	call write_sob_if_not_void


push SOB_NIL_ADDRESS

mov rax, qword [fvar_tbl + 8*22]

push rax

push 1
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode_486015704)
jmp Lcont_486015704
Lcode_486015704:
push rbp
mov rbp, rsp

mov rsi, [rbp + 8 * 3]			;; (*rsi holds the number of parametres on the stack*)
inc rsi
lea rsi, [rsi * 8]
MALLOC rdx, rsi			;; (*now rdx points to the allocated memory for the new vector*)
mov rcx, [rbp + 8 * 3]
mov rdi, 0			;;(*rdi will be used to point to the next address in the vector*)

mov r9, 4
;; (*start of loop to copy parameters to the new allocated vector*)
copy_params_loop_906512134:
cmp rdi, rcx
je after_params_copy_906512134
mov rsi, [rbp + 8 * r9]			;;(*now rsi points to the next parameter on the stack*)
mov [rdx + 8*rdi], rsi			;;(*copying the parameter to the new allocated vector*)
inc rdi
inc r9
jmp copy_params_loop_906512134
;; (*now rdx points to the new vector to be added to ext_env*)
;; (*mov 0 to all neccessary registers*)
after_params_copy_906512134:
mov qword [rdx + 8*rdi], SOB_NIL_ADDRESS
mov rcx, 0
mov rdi, 0
mov rsi, 0
;; (*now we need to create ext_env by copying env and adding the new vector*)
MALLOC rbx, 16			;;(*rbx points to a new allocated space for ext_env*)
mov [rbx], rdx			;;(*coping the new vector to ext_env[0]*)
mov rsi, [rbp + 8 * 2]			;;(*rsi points to current env*)
mov rcx, 1			;;(*rcx is the loop counter*)
mov r9, 0			;;(*r9 will be used to point to the next vector in current env to be copied*)
mov rdi, 1			;;(*rdi will be used to point to the next address in ext_env*)
mov r8, 0
;; (*start of loop for copying env[i] to ext_env[i+1]*)
copy_env_loop_906512134:
cmp r9, rcx
je after_env_copy_906512134
mov r8, [rsi + 8 * r9]			;;(*r8 points to the next vector int current env to be copied*) 
mov [rbx + 8 * rdi], r8			;;(*copying the pointer to the vector from env to ext_env*)
inc r9
inc rdi
jmp copy_env_loop_906512134
after_env_copy_906512134:

MAKE_CLOSURE(rax, rbx, Lcode_906512134)
jmp Lcont_906512134
Lcode_906512134:
push rbp
mov rbp, rsp

push SOB_NIL_ADDRESS

mov rax, const_tbl+41

push rax

mov qword rax, [rbp + 32]

push rax

push 2
mov rax, qword [rbp + 16]
mov rax, qword [rax + 0]
mov rax, qword [rax + 0]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_560617979:

leave
ret
Lcont_906512134:


leave
ret
Lcont_486015704:


push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_382642037:

mov [fvar_tbl + 8*41], rax
mov rax, SOB_VOID_ADDRESS
	call write_sob_if_not_void


push SOB_NIL_ADDRESS

mov rax, qword [fvar_tbl + 8*19]

push rax

mov rax, qword [fvar_tbl + 8*21]

push rax

mov rax, qword [fvar_tbl + 8*9]

push rax

mov rax, qword [fvar_tbl + 8*10]

push rax

push 4
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode_66750478)
jmp Lcont_66750478
Lcode_66750478:
push rbp
mov rbp, rsp

mov rsi, [rbp + 8 * 3]			;; (*rsi holds the number of parametres on the stack*)
inc rsi
lea rsi, [rsi * 8]
MALLOC rdx, rsi			;; (*now rdx points to the allocated memory for the new vector*)
mov rcx, [rbp + 8 * 3]
mov rdi, 0			;;(*rdi will be used to point to the next address in the vector*)

mov r9, 4
;; (*start of loop to copy parameters to the new allocated vector*)
copy_params_loop_111811881:
cmp rdi, rcx
je after_params_copy_111811881
mov rsi, [rbp + 8 * r9]			;;(*now rsi points to the next parameter on the stack*)
mov [rdx + 8*rdi], rsi			;;(*copying the parameter to the new allocated vector*)
inc rdi
inc r9
jmp copy_params_loop_111811881
;; (*now rdx points to the new vector to be added to ext_env*)
;; (*mov 0 to all neccessary registers*)
after_params_copy_111811881:
mov qword [rdx + 8*rdi], SOB_NIL_ADDRESS
mov rcx, 0
mov rdi, 0
mov rsi, 0
;; (*now we need to create ext_env by copying env and adding the new vector*)
MALLOC rbx, 16			;;(*rbx points to a new allocated space for ext_env*)
mov [rbx], rdx			;;(*coping the new vector to ext_env[0]*)
mov rsi, [rbp + 8 * 2]			;;(*rsi points to current env*)
mov rcx, 1			;;(*rcx is the loop counter*)
mov r9, 0			;;(*r9 will be used to point to the next vector in current env to be copied*)
mov rdi, 1			;;(*rdi will be used to point to the next address in ext_env*)
mov r8, 0
;; (*start of loop for copying env[i] to ext_env[i+1]*)
copy_env_loop_111811881:
cmp r9, rcx
je after_env_copy_111811881
mov r8, [rsi + 8 * r9]			;;(*r8 points to the next vector int current env to be copied*) 
mov [rbx + 8 * rdi], r8			;;(*copying the pointer to the vector from env to ext_env*)
inc r9
inc rdi
jmp copy_env_loop_111811881
after_env_copy_111811881:

MAKE_CLOSURE(rax, rbx, Lcode_111811881)
jmp Lcont_111811881
Lcode_111811881:
push rbp
mov rbp, rsp

push SOB_NIL_ADDRESS

mov rax, const_tbl+23

push rax

push 1

mov rsi, [rbp + 8 * 3]			;; (*rsi holds the number of parametres on the stack*)
inc rsi
lea rsi, [rsi * 8]
MALLOC rdx, rsi			;; (*now rdx points to the allocated memory for the new vector*)
mov rcx, [rbp + 8 * 3]
mov rdi, 0			;;(*rdi will be used to point to the next address in the vector*)

mov r9, 4
;; (*start of loop to copy parameters to the new allocated vector*)
copy_params_loop_81478918:
cmp rdi, rcx
je after_params_copy_81478918
mov rsi, [rbp + 8 * r9]			;;(*now rsi points to the next parameter on the stack*)
mov [rdx + 8*rdi], rsi			;;(*copying the parameter to the new allocated vector*)
inc rdi
inc r9
jmp copy_params_loop_81478918
;; (*now rdx points to the new vector to be added to ext_env*)
;; (*mov 0 to all neccessary registers*)
after_params_copy_81478918:
mov qword [rdx + 8*rdi], SOB_NIL_ADDRESS
mov rcx, 0
mov rdi, 0
mov rsi, 0
;; (*now we need to create ext_env by copying env and adding the new vector*)
MALLOC rbx, 24			;;(*rbx points to a new allocated space for ext_env*)
mov [rbx], rdx			;;(*coping the new vector to ext_env[0]*)
mov rsi, [rbp + 8 * 2]			;;(*rsi points to current env*)
mov rcx, 2			;;(*rcx is the loop counter*)
mov r9, 0			;;(*r9 will be used to point to the next vector in current env to be copied*)
mov rdi, 1			;;(*rdi will be used to point to the next address in ext_env*)
mov r8, 0
;; (*start of loop for copying env[i] to ext_env[i+1]*)
copy_env_loop_81478918:
cmp r9, rcx
je after_env_copy_81478918
mov r8, [rsi + 8 * r9]			;;(*r8 points to the next vector int current env to be copied*) 
mov [rbx + 8 * rdi], r8			;;(*copying the pointer to the vector from env to ext_env*)
inc r9
inc rdi
jmp copy_env_loop_81478918
after_env_copy_81478918:

MAKE_CLOSURE(rax, rbx, Lcode_81478918)
jmp Lcont_81478918
Lcode_81478918:
push rbp
mov rbp, rsp

mov qword rax, [rbp + 32]
MALLOC r11, 8
mov qword [r11], rax
mov rax, r11

mov qword [rbp + 32], rax
mov rax, SOB_VOID_ADDRESS




mov rsi, [rbp + 8 * 3]			;; (*rsi holds the number of parametres on the stack*)
inc rsi
lea rsi, [rsi * 8]
MALLOC rdx, rsi			;; (*now rdx points to the allocated memory for the new vector*)
mov rcx, [rbp + 8 * 3]
mov rdi, 0			;;(*rdi will be used to point to the next address in the vector*)

mov r9, 4
;; (*start of loop to copy parameters to the new allocated vector*)
copy_params_loop_668997420:
cmp rdi, rcx
je after_params_copy_668997420
mov rsi, [rbp + 8 * r9]			;;(*now rsi points to the next parameter on the stack*)
mov [rdx + 8*rdi], rsi			;;(*copying the parameter to the new allocated vector*)
inc rdi
inc r9
jmp copy_params_loop_668997420
;; (*now rdx points to the new vector to be added to ext_env*)
;; (*mov 0 to all neccessary registers*)
after_params_copy_668997420:
mov qword [rdx + 8*rdi], SOB_NIL_ADDRESS
mov rcx, 0
mov rdi, 0
mov rsi, 0
;; (*now we need to create ext_env by copying env and adding the new vector*)
MALLOC rbx, 32			;;(*rbx points to a new allocated space for ext_env*)
mov [rbx], rdx			;;(*coping the new vector to ext_env[0]*)
mov rsi, [rbp + 8 * 2]			;;(*rsi points to current env*)
mov rcx, 3			;;(*rcx is the loop counter*)
mov r9, 0			;;(*r9 will be used to point to the next vector in current env to be copied*)
mov rdi, 1			;;(*rdi will be used to point to the next address in ext_env*)
mov r8, 0
;; (*start of loop for copying env[i] to ext_env[i+1]*)
copy_env_loop_668997420:
cmp r9, rcx
je after_env_copy_668997420
mov r8, [rsi + 8 * r9]			;;(*r8 points to the next vector int current env to be copied*) 
mov [rbx + 8 * rdi], r8			;;(*copying the pointer to the vector from env to ext_env*)
inc r9
inc rdi
jmp copy_env_loop_668997420
after_env_copy_668997420:

MAKE_CLOSURE(rax, rbx, Lcode_668997420)
jmp Lcont_668997420
Lcode_668997420:
push rbp
mov rbp, rsp

push SOB_NIL_ADDRESS

mov rax, const_tbl+41

push rax

mov qword rax, [rbp + 32]

push rax

push 2
mov rax, qword [rbp + 16]
mov rax, qword [rax + 16]
mov rax, qword [rax + 16]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_243779707:

cmp rax, SOB_FALSE_ADDRESS
je Lelse_562514557
mov qword rax, [rbp + 40]

jmp Lexit_64012633
Lelse_562514557:

push SOB_NIL_ADDRESS


push SOB_NIL_ADDRESS

mov qword rax, [rbp + 40]

push rax


push SOB_NIL_ADDRESS

mov qword rax, [rbp + 32]

push rax

mov rax, qword [rbp + 16]
mov rax, qword [rax + 8]
mov rax, qword [rax + 0]

push rax

push 2
mov rax, qword [rbp + 16]
mov rax, qword [rax + 16]
mov rax, qword [rax + 0]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_578335420:

push rax

push 2
mov rax, qword [fvar_tbl + 8*25]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_363499359:

push rax


push SOB_NIL_ADDRESS

mov rax, const_tbl+32

push rax

mov qword rax, [rbp + 32]

push rax

push 2
mov rax, qword [rbp + 16]
mov rax, qword [rax + 16]
mov rax, qword [rax + 24]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_360549859:

push rax

push 2
mov rax, qword [rbp + 16]
mov rax, qword [rax + 0]
mov rax, qword [rax + 0]

mov rax, qword [rax]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_460100181:

Lexit_64012633:

leave
ret
Lcont_668997420:


push rax
mov qword rax, [rbp + 32]

pop qword [rax]
mov rax, SOB_VOID_ADDRESS



push SOB_NIL_ADDRESS

mov rax, const_tbl+1

push rax


push SOB_NIL_ADDRESS

mov rax, const_tbl+32

push rax


push SOB_NIL_ADDRESS

mov rax, qword [rbp + 16]
mov rax, qword [rax + 0]
mov rax, qword [rax + 0]

push rax

push 1
mov rax, qword [rbp + 16]
mov rax, qword [rax + 8]
mov rax, qword [rax + 8]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_271720753:

push rax

push 2
mov rax, qword [rbp + 16]
mov rax, qword [rax + 8]
mov rax, qword [rax + 24]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_822188825:

push rax

push 2
mov qword rax, [rbp + 32]

mov rax, qword [rax]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_631183990:



leave
ret
Lcont_81478918:


push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_839199170:

leave
ret
Lcont_111811881:


leave
ret
Lcont_66750478:


push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_895730577:

mov [fvar_tbl + 8*42], rax
mov rax, SOB_VOID_ADDRESS
	call write_sob_if_not_void


push SOB_NIL_ADDRESS

mov rax, qword [fvar_tbl + 8*14]

push rax

mov rax, qword [fvar_tbl + 8*24]

push rax

mov rax, qword [fvar_tbl + 8*23]

push rax

mov rax, qword [fvar_tbl + 8*16]

push rax

mov rax, qword [fvar_tbl + 8*6]

push rax

mov rax, qword [fvar_tbl + 8*5]

push rax

mov rax, qword [fvar_tbl + 8*3]

push rax

mov rax, qword [fvar_tbl + 8*1]

push rax

mov rax, qword [fvar_tbl + 8*2]

push rax

mov rax, qword [fvar_tbl + 8*42]

push rax

mov rax, qword [fvar_tbl + 8*22]

push rax

push 11
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode_230780211)
jmp Lcont_230780211
Lcode_230780211:
push rbp
mov rbp, rsp

push SOB_NIL_ADDRESS

mov rax, const_tbl+23

push rax

push 1

mov rsi, [rbp + 8 * 3]			;; (*rsi holds the number of parametres on the stack*)
inc rsi
lea rsi, [rsi * 8]
MALLOC rdx, rsi			;; (*now rdx points to the allocated memory for the new vector*)
mov rcx, [rbp + 8 * 3]
mov rdi, 0			;;(*rdi will be used to point to the next address in the vector*)

mov r9, 4
;; (*start of loop to copy parameters to the new allocated vector*)
copy_params_loop_830445955:
cmp rdi, rcx
je after_params_copy_830445955
mov rsi, [rbp + 8 * r9]			;;(*now rsi points to the next parameter on the stack*)
mov [rdx + 8*rdi], rsi			;;(*copying the parameter to the new allocated vector*)
inc rdi
inc r9
jmp copy_params_loop_830445955
;; (*now rdx points to the new vector to be added to ext_env*)
;; (*mov 0 to all neccessary registers*)
after_params_copy_830445955:
mov qword [rdx + 8*rdi], SOB_NIL_ADDRESS
mov rcx, 0
mov rdi, 0
mov rsi, 0
;; (*now we need to create ext_env by copying env and adding the new vector*)
MALLOC rbx, 16			;;(*rbx points to a new allocated space for ext_env*)
mov [rbx], rdx			;;(*coping the new vector to ext_env[0]*)
mov rsi, [rbp + 8 * 2]			;;(*rsi points to current env*)
mov rcx, 1			;;(*rcx is the loop counter*)
mov r9, 0			;;(*r9 will be used to point to the next vector in current env to be copied*)
mov rdi, 1			;;(*rdi will be used to point to the next address in ext_env*)
mov r8, 0
;; (*start of loop for copying env[i] to ext_env[i+1]*)
copy_env_loop_830445955:
cmp r9, rcx
je after_env_copy_830445955
mov r8, [rsi + 8 * r9]			;;(*r8 points to the next vector int current env to be copied*) 
mov [rbx + 8 * rdi], r8			;;(*copying the pointer to the vector from env to ext_env*)
inc r9
inc rdi
jmp copy_env_loop_830445955
after_env_copy_830445955:

MAKE_CLOSURE(rax, rbx, Lcode_830445955)
jmp Lcont_830445955
Lcode_830445955:
push rbp
mov rbp, rsp

mov qword rax, [rbp + 32]
MALLOC r11, 8
mov qword [r11], rax
mov rax, r11

mov qword [rbp + 32], rax
mov rax, SOB_VOID_ADDRESS




mov rsi, [rbp + 8 * 3]			;; (*rsi holds the number of parametres on the stack*)
inc rsi
lea rsi, [rsi * 8]
MALLOC rdx, rsi			;; (*now rdx points to the allocated memory for the new vector*)
mov rcx, [rbp + 8 * 3]
mov rdi, 0			;;(*rdi will be used to point to the next address in the vector*)

mov r9, 4
;; (*start of loop to copy parameters to the new allocated vector*)
copy_params_loop_667740834:
cmp rdi, rcx
je after_params_copy_667740834
mov rsi, [rbp + 8 * r9]			;;(*now rsi points to the next parameter on the stack*)
mov [rdx + 8*rdi], rsi			;;(*copying the parameter to the new allocated vector*)
inc rdi
inc r9
jmp copy_params_loop_667740834
;; (*now rdx points to the new vector to be added to ext_env*)
;; (*mov 0 to all neccessary registers*)
after_params_copy_667740834:
mov qword [rdx + 8*rdi], SOB_NIL_ADDRESS
mov rcx, 0
mov rdi, 0
mov rsi, 0
;; (*now we need to create ext_env by copying env and adding the new vector*)
MALLOC rbx, 24			;;(*rbx points to a new allocated space for ext_env*)
mov [rbx], rdx			;;(*coping the new vector to ext_env[0]*)
mov rsi, [rbp + 8 * 2]			;;(*rsi points to current env*)
mov rcx, 2			;;(*rcx is the loop counter*)
mov r9, 0			;;(*r9 will be used to point to the next vector in current env to be copied*)
mov rdi, 1			;;(*rdi will be used to point to the next address in ext_env*)
mov r8, 0
;; (*start of loop for copying env[i] to ext_env[i+1]*)
copy_env_loop_667740834:
cmp r9, rcx
je after_env_copy_667740834
mov r8, [rsi + 8 * r9]			;;(*r8 points to the next vector int current env to be copied*) 
mov [rbx + 8 * rdi], r8			;;(*copying the pointer to the vector from env to ext_env*)
inc r9
inc rdi
jmp copy_env_loop_667740834
after_env_copy_667740834:

MAKE_CLOSURE(rax, rbx, Lcode_667740834)
jmp Lcont_667740834
Lcode_667740834:
push rbp
mov rbp, rsp

push SOB_NIL_ADDRESS

mov qword rax, [rbp + 32]

push rax

push 1
mov rax, qword [rbp + 16]
mov rax, qword [rax + 8]
mov rax, qword [rax + 16]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_53715045:

cmp rax, SOB_FALSE_ADDRESS
je Lelse_634945416

push SOB_NIL_ADDRESS

mov qword rax, [rbp + 40]

push rax

push 1
mov rax, qword [rbp + 16]
mov rax, qword [rax + 8]
mov rax, qword [rax + 16]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_170902041:

cmp rax, SOB_FALSE_ADDRESS
je Lelse_489280857

push SOB_NIL_ADDRESS

mov qword rax, [rbp + 40]

push rax

mov qword rax, [rbp + 32]

push rax

push 2
mov rax, qword [rbp + 16]
mov rax, qword [rax + 8]
mov rax, qword [rax + 0]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_303249613:

jmp Lexit_37853549
Lelse_489280857:
mov rax, const_tbl+2

Lexit_37853549:

jmp Lexit_151230915
Lelse_634945416:
mov rax, const_tbl+2

Lexit_151230915:

cmp rax, SOB_FALSE_ADDRESS
jne Lexit_93771885

push SOB_NIL_ADDRESS

mov qword rax, [rbp + 32]

push rax

push 1
mov rax, qword [rbp + 16]
mov rax, qword [rax + 8]
mov rax, qword [rax + 24]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_772529697:

cmp rax, SOB_FALSE_ADDRESS
je Lelse_588220468

push SOB_NIL_ADDRESS

mov qword rax, [rbp + 40]

push rax

push 1
mov rax, qword [rbp + 16]
mov rax, qword [rax + 8]
mov rax, qword [rax + 24]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_970335524:

cmp rax, SOB_FALSE_ADDRESS
je Lelse_625546569

push SOB_NIL_ADDRESS

mov qword rax, [rbp + 40]

push rax

mov qword rax, [rbp + 32]

push rax

push 2
mov rax, qword [rbp + 16]
mov rax, qword [rax + 8]
mov rax, qword [rax + 0]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_344029323:

jmp Lexit_231096776
Lelse_625546569:
mov rax, const_tbl+2

Lexit_231096776:

jmp Lexit_37125678
Lelse_588220468:
mov rax, const_tbl+2

Lexit_37125678:

cmp rax, SOB_FALSE_ADDRESS
jne Lexit_93771885

push SOB_NIL_ADDRESS

mov qword rax, [rbp + 32]

push rax

push 1
mov rax, qword [rbp + 16]
mov rax, qword [rax + 8]
mov rax, qword [rax + 32]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_49135310:

cmp rax, SOB_FALSE_ADDRESS
je Lelse_116124369

push SOB_NIL_ADDRESS

mov qword rax, [rbp + 40]

push rax

push 1
mov rax, qword [rbp + 16]
mov rax, qword [rax + 8]
mov rax, qword [rax + 32]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_35009346:

cmp rax, SOB_FALSE_ADDRESS
je Lelse_747844691

push SOB_NIL_ADDRESS


push SOB_NIL_ADDRESS

mov qword rax, [rbp + 40]

push rax

push 1
mov rax, qword [rbp + 16]
mov rax, qword [rax + 8]
mov rax, qword [rax + 64]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_66860662:

push rax


push SOB_NIL_ADDRESS

mov qword rax, [rbp + 32]

push rax

push 1
mov rax, qword [rbp + 16]
mov rax, qword [rax + 8]
mov rax, qword [rax + 64]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_419625899:

push rax

push 2
mov rax, qword [rbp + 16]
mov rax, qword [rax + 0]
mov rax, qword [rax + 0]

mov rax, qword [rax]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_787224177:

cmp rax, SOB_FALSE_ADDRESS
je Lelse_798681974

push SOB_NIL_ADDRESS


push SOB_NIL_ADDRESS

mov qword rax, [rbp + 40]

push rax

push 1
mov rax, qword [rbp + 16]
mov rax, qword [rax + 8]
mov rax, qword [rax + 72]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_988088953:

push rax


push SOB_NIL_ADDRESS

mov qword rax, [rbp + 32]

push rax

push 1
mov rax, qword [rbp + 16]
mov rax, qword [rax + 8]
mov rax, qword [rax + 72]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_232886063:

push rax

push 2
mov rax, qword [rbp + 16]
mov rax, qword [rax + 0]
mov rax, qword [rax + 0]

mov rax, qword [rax]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_579787587:

jmp Lexit_630804862
Lelse_798681974:
mov rax, const_tbl+2

Lexit_630804862:

jmp Lexit_246627487
Lelse_747844691:
mov rax, const_tbl+2

Lexit_246627487:

jmp Lexit_100958969
Lelse_116124369:
mov rax, const_tbl+2

Lexit_100958969:

cmp rax, SOB_FALSE_ADDRESS
jne Lexit_93771885

push SOB_NIL_ADDRESS

mov qword rax, [rbp + 32]

push rax

push 1
mov rax, qword [rbp + 16]
mov rax, qword [rax + 8]
mov rax, qword [rax + 40]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_612717911:

cmp rax, SOB_FALSE_ADDRESS
je Lelse_609785659

push SOB_NIL_ADDRESS

mov qword rax, [rbp + 40]

push rax

push 1
mov rax, qword [rbp + 16]
mov rax, qword [rax + 8]
mov rax, qword [rax + 40]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_297010890:

cmp rax, SOB_FALSE_ADDRESS
je Lelse_3761444

push SOB_NIL_ADDRESS


push SOB_NIL_ADDRESS

mov qword rax, [rbp + 40]

push rax

push 1
mov rax, qword [rbp + 16]
mov rax, qword [rax + 8]
mov rax, qword [rax + 80]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_72469400:

push rax


push SOB_NIL_ADDRESS

mov qword rax, [rbp + 32]

push rax

push 1
mov rax, qword [rbp + 16]
mov rax, qword [rax + 8]
mov rax, qword [rax + 80]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_306916575:

push rax

push 2
mov rax, qword [rbp + 16]
mov rax, qword [rax + 8]
mov rax, qword [rax + 0]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_217560096:

jmp Lexit_402783938
Lelse_3761444:
mov rax, const_tbl+2

Lexit_402783938:

jmp Lexit_528749989
Lelse_609785659:
mov rax, const_tbl+2

Lexit_528749989:

cmp rax, SOB_FALSE_ADDRESS
jne Lexit_93771885

push SOB_NIL_ADDRESS

mov qword rax, [rbp + 32]

push rax

push 1
mov rax, qword [rbp + 16]
mov rax, qword [rax + 8]
mov rax, qword [rax + 48]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_839435742:

cmp rax, SOB_FALSE_ADDRESS
je Lelse_427470990

push SOB_NIL_ADDRESS

mov qword rax, [rbp + 40]

push rax

push 1
mov rax, qword [rbp + 16]
mov rax, qword [rax + 8]
mov rax, qword [rax + 48]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_941339251:

cmp rax, SOB_FALSE_ADDRESS
je Lelse_720473698

push SOB_NIL_ADDRESS


push SOB_NIL_ADDRESS

mov qword rax, [rbp + 40]

push rax

push 1
mov rax, qword [rbp + 16]
mov rax, qword [rax + 8]
mov rax, qword [rax + 8]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_25705927:

push rax


push SOB_NIL_ADDRESS

mov qword rax, [rbp + 32]

push rax

push 1
mov rax, qword [rbp + 16]
mov rax, qword [rax + 8]
mov rax, qword [rax + 8]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_165446385:

push rax

push 2
mov rax, qword [rbp + 16]
mov rax, qword [rax + 0]
mov rax, qword [rax + 0]

mov rax, qword [rax]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_453879695:

jmp Lexit_654168528
Lelse_720473698:
mov rax, const_tbl+2

Lexit_654168528:

jmp Lexit_410897316
Lelse_427470990:
mov rax, const_tbl+2

Lexit_410897316:

cmp rax, SOB_FALSE_ADDRESS
jne Lexit_93771885

push SOB_NIL_ADDRESS

mov qword rax, [rbp + 40]

push rax

mov qword rax, [rbp + 32]

push rax

push 2
mov rax, qword [rbp + 16]
mov rax, qword [rax + 8]
mov rax, qword [rax + 56]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_100586209:

Lexit_93771885:

leave
ret
Lcont_667740834:


push rax
mov qword rax, [rbp + 32]

pop qword [rax]
mov rax, SOB_VOID_ADDRESS


mov qword rax, [rbp + 32]

mov rax, qword [rax]



leave
ret
Lcont_830445955:


push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_937727265:

leave
ret
Lcont_230780211:


push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_94509538:

mov [fvar_tbl + 8*43], rax
mov rax, SOB_VOID_ADDRESS
	call write_sob_if_not_void


push SOB_NIL_ADDRESS

mov rax, const_tbl+131

push rax

mov rax, const_tbl+61

push rax

mov rax, const_tbl+52

push rax

mov rax, const_tbl+32

push rax

mov rax, qword [fvar_tbl + 8*17]

push rax

push 5
mov rax, qword [fvar_tbl + 8*28]

push qword [rax + 1]			;;(*pushing env on the stack*)
call [rax + 9]
add rsp, 8			;;(*popping the environment pointer*)
pop rbx			;;(*popping and saving the argument counter in rbx*)
shl rbx, 3			;;(*now rbx holds the sum of sizes of all the arguments to pop*)
add rsp, rbx			;;(*popping all the arguments*)
add rsp, 8
after_applic_666619395:

	call write_sob_if_not_void

	mov rax, 0
	add rsp, 4*8
	pop rbp
	ret

car:
    push rbp
    mov rbp, rsp
    mov rsi, PVAR(0)    ; now rsi points to the possible pair
    CAR rax, rsi   ; now rax points to the car of the pair
    leave
    ret

cdr:
    push rbp
    mov rbp, rsp
    mov rsi, PVAR(0)    ; now rsi points to the possible pair
    CDR rax, rsi    ; now rax points to the cdr of the pair
    leave
    ret
cons_make:
    push rbp
    mov rbp, rsp
    mov rsi, PVAR(0)    ; now rsi points to the possible pair
    mov rdi, PVAR(1)
    MAKE_PAIR(rax, rsi ,rdi)
    leave
    ret
set_car:
    push rbp
    mov rbp, rsp
    mov rsi, PVAR(0)    ; now rsi points to the possible pair
    mov rdi, PVAR(1)    ; now rsi points to the possible pair
    mov qword [rsi+TYPE_SIZE],rdi
    leave 
    ret

set_cdr:
    push rbp
    mov rbp, rsp
    mov rsi, PVAR(0)    ; now rsi points to the possible pair
    mov rdi, PVAR(1)    ; now rsi points to the possible pair
    mov qword [rsi+TYPE_SIZE+WORD_SIZE],rdi
    leave 
    ret

apply:
    push rbp
    mov rbp, rsp
    mov rcx, qword [rbp + 8 * 3]   ; rcx holds the current args count
    mov r11, 0          ; cleaning r11 - r11 will hold the list length
    mov rsi, rcx                   ; rsi will hold at the end of the first loop the new argument count
    mov qword rbx, PVAR(0)         ; rbx points to the procedure to be applied
    dec rcx
    mov rdx, PVAR(rcx)             ; rdx holds the last parameter of apply which is a list
    dec rsi                         ; decrementing because we don't want to include the procedure argument
    dec rsi                         ; decrementing again because we don't want to include the list argument
    calculate_new_args_count_apply:     ; iterating over the list argument
       cmp rdx, SOB_NIL_ADDRESS
       je end_calculate_new_args_count_apply
       inc rsi                     ; incrementing the new number of argumnets
       inc r11                      ; incrementing the list length
       CDR rdx, rdx                 ; advancing to the next member of the list argument
       jmp calculate_new_args_count_apply
    end_calculate_new_args_count_apply:
    ; now rsi holds the new args count
    mov r9, 0
    mov r10, 0
    mov rcx, qword [rbp + 8 * 3]   ; rcx holds the current args count
    dec rcx                         ; rcx will be our loop counter
    dec rcx                         ; decrementing again because we don't want to include the procedure and the list argument
    lea r10, [rsi*8]        ; r10 holds the size of memory that is needed to save all the non list arguments
    MALLOC r9, r10          ; r9 points to the memory to save all the non list arguments
    mov r10, 1
    mov rdi, 0
    pop_and_save_all_non_list_arguments:
        cmp r10, rcx
        jg save_all_list_members
        mov rdi, PVAR(r10)      ; rdi holds the next argument to be saved
        mov qword [r9 + 8*r10], rdi ; saving the next argument in the new arguments vector
        inc r10
        jmp pop_and_save_all_non_list_arguments
    ; we saved all the non-list argumnets
    ; now we need to save all the members of the list as separate arguments
    ; r10 still points to the next address of the allocated memory to insert the next argument
    ; r9 still points to the vector of the new arguments 
    save_all_list_members:
        mov rcx, 0
        mov rcx, qword [rbp + 8 * 3]   ; rcx holds the current args count
        dec rcx
        mov rdx, 0
        mov r11, 0                  ; r11 will be used to save the next member of the list argument
        mov rdx, PVAR(rcx)          ; now rdx point to the list argument of apply
        save_all_list_members_loop:
            cmp rdx, SOB_NIL_ADDRESS
            je end_save_all_list_members
            CAR r11, rdx            ; next member in the list is in r11
            mov qword [r9 + r10*8], r11     ; saving the member in the new arguments vector
            inc r10
            CDR rdx, rdx                ; advancing to the next member of the list
            jmp save_all_list_members_loop
    end_save_all_list_members:
    ; first we need to clear the stack
    clear_stack:
        mov r8, 0
        mov r10, 0
        mov r11, 0
        mov r12, 0
        mov r8, qword [rbp + 8]                ; r8 holds the old ret address
        mov r10, qword [rbp + 8 * 2]            ; r10 points to the current env
        mov r11, qword [rbp + 8 * 3]       ; r11 holds the old args count
        add rsp, 32                         ; poping old rbp, old ret address, curr env and old args count
        lea r12, [r11 * 8]                  ; size of all the arguments is saved in r12
        add rsp, r12                        ; popping all the arguments
    ; now we need to push the new arguments on the stack
    ; push SOB_NIL_ADDRESS    ; pushing magic argument
    push_new_arguments:
    ; r9 points to a vector with all the arguments
    ; rsi is the number of arguments
        mov r12, 0
        mov r12, rsi         ; r12 holds the new number of arguments
        ; dec r12
        push_new_arguments_loop:        ; pushing all the new arguments from last to first
            cmp r12, 0
            je end_push_new_arguments
            push qword [r9 + 8*r12]
            dec r12
            jmp push_new_arguments_loop
    end_push_new_arguments:
    ; now we need to push the new args_count, the old env and the old ret address
    ; rbx still points to the procedure argument of apply
    push rsi        ; pushing new args count
    push qword [rbx + 1]        ; pushing the closure env on the stack
    push r8         ; pushing the old ret address
    jmp [rbx + 9]        ; calling the procedure argument
    ;leave 
    ;ret

is_boolean:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov sil, byte [rsi]

    cmp sil, T_BOOL
    jne .wrong_type
    mov rax, SOB_TRUE_ADDRESS
    jmp .return

.wrong_type:
    mov rax, SOB_FALSE_ADDRESS
.return:
    leave
    ret

is_float:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov sil, byte [rsi]

    cmp sil, T_FLOAT
    jne .wrong_type
    mov rax, SOB_TRUE_ADDRESS
    jmp .return

.wrong_type:
    mov rax, SOB_FALSE_ADDRESS
.return:
    leave
    ret

is_integer:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov sil, byte [rsi]

    cmp sil, T_INTEGER
    jne .wrong_type
    mov rax, SOB_TRUE_ADDRESS
    jmp .return

.wrong_type:
    mov rax, SOB_FALSE_ADDRESS
.return:
    leave
    ret

is_pair:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov sil, byte [rsi]

    cmp sil, T_PAIR
    jne .wrong_type
    mov rax, SOB_TRUE_ADDRESS
    jmp .return

.wrong_type:
    mov rax, SOB_FALSE_ADDRESS
.return:
    leave
    ret

is_null:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov sil, byte [rsi]

    cmp sil, T_NIL
    jne .wrong_type
    mov rax, SOB_TRUE_ADDRESS
    jmp .return

.wrong_type:
    mov rax, SOB_FALSE_ADDRESS
.return:
    leave
    ret

is_char:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov sil, byte [rsi]

    cmp sil, T_CHAR
    jne .wrong_type
    mov rax, SOB_TRUE_ADDRESS
    jmp .return

.wrong_type:
    mov rax, SOB_FALSE_ADDRESS
.return:
    leave
    ret

is_string:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov sil, byte [rsi]

    cmp sil, T_STRING
    jne .wrong_type
    mov rax, SOB_TRUE_ADDRESS
    jmp .return

.wrong_type:
    mov rax, SOB_FALSE_ADDRESS
.return:
    leave
    ret

is_procedure:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov sil, byte [rsi]

    cmp sil, T_CLOSURE
    jne .wrong_type
    mov rax, SOB_TRUE_ADDRESS
    jmp .return

.wrong_type:
    mov rax, SOB_FALSE_ADDRESS
.return:
    leave
    ret

is_symbol:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov sil, byte [rsi]

    cmp sil, T_SYMBOL
    jne .wrong_type
    mov rax, SOB_TRUE_ADDRESS
    jmp .return

.wrong_type:
    mov rax, SOB_FALSE_ADDRESS
.return:
    leave
    ret

string_length:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    STRING_LENGTH rsi, rsi
    MAKE_INT(rax, rsi)

    leave
    ret

string_ref:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0) 
    STRING_ELEMENTS rsi, rsi
    mov rdi, PVAR(1)
    INT_VAL rdi, rdi
    shl rdi, 0
    add rsi, rdi

    mov sil, byte [rsi]
    MAKE_CHAR(rax, sil)

    leave
    ret

string_set:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0) 
    STRING_ELEMENTS rsi, rsi
    mov rdi, PVAR(1)
    INT_VAL rdi, rdi
    shl rdi, 0
    add rsi, rdi

    mov rax, PVAR(2)
    CHAR_VAL rax, rax
    mov byte [rsi], al
    mov rax, SOB_VOID_ADDRESS

    leave
    ret

make_string:
    push rbp
    mov rbp, rsp

    
    mov rsi, PVAR(0)
    INT_VAL rsi, rsi
    mov rdi, PVAR(1)
    CHAR_VAL rdi, rdi
    and rdi, 255

    MAKE_STRING rax, rsi, dil

    leave
    ret

symbol_to_string:
    push rbp
    mov rbp, rsp

    
    mov rsi, PVAR(0)
    SYMBOL_VAL rsi, rsi
    
    STRING_LENGTH rcx, rsi
    STRING_ELEMENTS rdi, rsi

    push rcx
    push rdi

    mov dil, byte [rdi]
    MAKE_CHAR(rax, dil)
    push rax
    MAKE_INT(rax, rcx)
    push rax
    push 2
    push SOB_NIL_ADDRESS
    call make_string
    add rsp, 4*8

    STRING_ELEMENTS rsi, rax

    pop rdi
    pop rcx

    cmp rcx, 0
    je .end
	
.loop:
    lea r8, [rdi+rcx]
    lea r9, [rsi+rcx]

    mov bl, byte [r8]
    mov byte [r9], bl
    
    loop .loop
.end:

    leave
    ret

char_to_integer:
    push rbp
    mov rbp, rsp

    
    mov rsi, PVAR(0)
    CHAR_VAL rsi, rsi
    and rsi, 255
    MAKE_INT(rax, rsi)

    leave
    ret

integer_to_char:
    push rbp
    mov rbp, rsp

    
    mov rsi, PVAR(0)
    INT_VAL rsi, rsi
    and rsi, 255
    MAKE_CHAR(rax, sil)

    leave
    ret

is_eq:
    push rbp
    mov rbp, rsp

    
    mov rsi, PVAR(0)
    mov rdi, PVAR(1)
    cmp rsi, rdi
    je .true
    mov rax, SOB_FALSE_ADDRESS
    jmp .return

.true:
    mov rax, SOB_TRUE_ADDRESS

.return:
    leave
    ret

bin_add:
    push rbp
    mov rbp, rsp

    mov r8, 0

    mov rsi, PVAR(0)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .test_next
    or r8, 1

.test_next:

    mov rsi, PVAR(1)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .load_numbers
    or r8, 2

.load_numbers:
    push r8

    shr r8, 1
    jc .first_arg_int
    mov rsi, PVAR(0)
    FLOAT_VAL rsi, rsi 
    movq xmm0, rsi
    jmp .load_next_float

.first_arg_int:
    mov rsi, PVAR(0)
    INT_VAL rsi, rsi
    cvtsi2sd xmm0, rsi

.load_next_float:
    shr r8, 1
    jc .second_arg_int
    mov rsi, PVAR(1)
    FLOAT_VAL rsi, rsi
    movq xmm1, rsi
    jmp .perform_float_op

.second_arg_int:
    mov rsi, PVAR(1)
    INT_VAL rsi, rsi
    cvtsi2sd xmm1, rsi

.perform_float_op:
    addsd xmm0, xmm1

    pop r8
    cmp r8, 3
    jne .return_float

    cvttsd2si rsi, xmm0
    MAKE_INT(rax, rsi)
    jmp .return

.return_float:
    movq rsi, xmm0
    MAKE_FLOAT(rax, rsi)

.return:

    leave
    ret

bin_mul:
    push rbp
    mov rbp, rsp

    mov r8, 0

    mov rsi, PVAR(0)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .test_next
    or r8, 1

.test_next:

    mov rsi, PVAR(1)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .load_numbers
    or r8, 2

.load_numbers:
    push r8

    shr r8, 1
    jc .first_arg_int
    mov rsi, PVAR(0)
    FLOAT_VAL rsi, rsi 
    movq xmm0, rsi
    jmp .load_next_float

.first_arg_int:
    mov rsi, PVAR(0)
    INT_VAL rsi, rsi
    cvtsi2sd xmm0, rsi

.load_next_float:
    shr r8, 1
    jc .second_arg_int
    mov rsi, PVAR(1)
    FLOAT_VAL rsi, rsi
    movq xmm1, rsi
    jmp .perform_float_op

.second_arg_int:
    mov rsi, PVAR(1)
    INT_VAL rsi, rsi
    cvtsi2sd xmm1, rsi

.perform_float_op:
    mulsd xmm0, xmm1

    pop r8
    cmp r8, 3
    jne .return_float

    cvttsd2si rsi, xmm0
    MAKE_INT(rax, rsi)
    jmp .return

.return_float:
    movq rsi, xmm0
    MAKE_FLOAT(rax, rsi)

.return:

    leave
    ret

bin_sub:
    push rbp
    mov rbp, rsp

    mov r8, 0

    mov rsi, PVAR(0)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .test_next
    or r8, 1

.test_next:

    mov rsi, PVAR(1)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .load_numbers
    or r8, 2

.load_numbers:
    push r8

    shr r8, 1
    jc .first_arg_int
    mov rsi, PVAR(0)
    FLOAT_VAL rsi, rsi 
    movq xmm0, rsi
    jmp .load_next_float

.first_arg_int:
    mov rsi, PVAR(0)
    INT_VAL rsi, rsi
    cvtsi2sd xmm0, rsi

.load_next_float:
    shr r8, 1
    jc .second_arg_int
    mov rsi, PVAR(1)
    FLOAT_VAL rsi, rsi
    movq xmm1, rsi
    jmp .perform_float_op

.second_arg_int:
    mov rsi, PVAR(1)
    INT_VAL rsi, rsi
    cvtsi2sd xmm1, rsi

.perform_float_op:
    subsd xmm0, xmm1

    pop r8
    cmp r8, 3
    jne .return_float

    cvttsd2si rsi, xmm0
    MAKE_INT(rax, rsi)
    jmp .return

.return_float:
    movq rsi, xmm0
    MAKE_FLOAT(rax, rsi)

.return:

    leave
    ret

bin_div:
    push rbp
    mov rbp, rsp

    mov r8, 0

    mov rsi, PVAR(0)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .test_next
    or r8, 1

.test_next:

    mov rsi, PVAR(1)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .load_numbers
    or r8, 2

.load_numbers:
    push r8

    shr r8, 1
    jc .first_arg_int
    mov rsi, PVAR(0)
    FLOAT_VAL rsi, rsi 
    movq xmm0, rsi
    jmp .load_next_float

.first_arg_int:
    mov rsi, PVAR(0)
    INT_VAL rsi, rsi
    cvtsi2sd xmm0, rsi

.load_next_float:
    shr r8, 1
    jc .second_arg_int
    mov rsi, PVAR(1)
    FLOAT_VAL rsi, rsi
    movq xmm1, rsi
    jmp .perform_float_op

.second_arg_int:
    mov rsi, PVAR(1)
    INT_VAL rsi, rsi
    cvtsi2sd xmm1, rsi

.perform_float_op:
    divsd xmm0, xmm1

    pop r8
    cmp r8, 3
    jne .return_float

    cvttsd2si rsi, xmm0
    MAKE_INT(rax, rsi)
    jmp .return

.return_float:
    movq rsi, xmm0
    MAKE_FLOAT(rax, rsi)

.return:

    leave
    ret

bin_lt:
    push rbp
    mov rbp, rsp

    mov r8, 0

    mov rsi, PVAR(0)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .test_next
    or r8, 1

.test_next:

    mov rsi, PVAR(1)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .load_numbers
    or r8, 2

.load_numbers:
    push r8

    shr r8, 1
    jc .first_arg_int
    mov rsi, PVAR(0)
    FLOAT_VAL rsi, rsi 
    movq xmm0, rsi
    jmp .load_next_float

.first_arg_int:
    mov rsi, PVAR(0)
    INT_VAL rsi, rsi
    cvtsi2sd xmm0, rsi

.load_next_float:
    shr r8, 1
    jc .second_arg_int
    mov rsi, PVAR(1)
    FLOAT_VAL rsi, rsi
    movq xmm1, rsi
    jmp .perform_float_op

.second_arg_int:
    mov rsi, PVAR(1)
    INT_VAL rsi, rsi
    cvtsi2sd xmm1, rsi

.perform_float_op:
    cmpltsd xmm0, xmm1

    pop r8
    cmp r8, 3
    jne .return_float

    cvttsd2si rsi, xmm0
    MAKE_INT(rax, rsi)
    jmp .return

.return_float:
    movq rsi, xmm0
    MAKE_FLOAT(rax, rsi)

.return:

    INT_VAL rsi, rax
    cmp rsi, 0
    je .return_false
    mov rax, SOB_TRUE_ADDRESS
    jmp .final_return

.return_false:
    mov rax, SOB_FALSE_ADDRESS

.final_return:


    leave
    ret

bin_equ:
    push rbp
    mov rbp, rsp

    mov r8, 0

    mov rsi, PVAR(0)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .test_next
    or r8, 1

.test_next:

    mov rsi, PVAR(1)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .load_numbers
    or r8, 2

.load_numbers:
    push r8

    shr r8, 1
    jc .first_arg_int
    mov rsi, PVAR(0)
    FLOAT_VAL rsi, rsi 
    movq xmm0, rsi
    jmp .load_next_float

.first_arg_int:
    mov rsi, PVAR(0)
    INT_VAL rsi, rsi
    cvtsi2sd xmm0, rsi

.load_next_float:
    shr r8, 1
    jc .second_arg_int
    mov rsi, PVAR(1)
    FLOAT_VAL rsi, rsi
    movq xmm1, rsi
    jmp .perform_float_op

.second_arg_int:
    mov rsi, PVAR(1)
    INT_VAL rsi, rsi
    cvtsi2sd xmm1, rsi

.perform_float_op:
    cmpeqsd xmm0, xmm1

    pop r8
    cmp r8, 3
    jne .return_float

    cvttsd2si rsi, xmm0
    MAKE_INT(rax, rsi)
    jmp .return

.return_float:
    movq rsi, xmm0
    MAKE_FLOAT(rax, rsi)

.return:

    INT_VAL rsi, rax
    cmp rsi, 0
    je .return_false
    mov rax, SOB_TRUE_ADDRESS
    jmp .final_return

.return_false:
    mov rax, SOB_FALSE_ADDRESS

.final_return:


    leave
    ret


